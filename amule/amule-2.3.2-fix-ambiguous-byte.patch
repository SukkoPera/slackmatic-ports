diff --git a/src/BaseClient.cpp b/src/BaseClient.cpp
index 0cfef1525..4282fcd20 100644
--- a/src/BaseClient.cpp
+++ b/src/BaseClient.cpp
@@ -361,7 +361,7 @@ void CUpDownClient::ClearHelloProperties()
 	m_bUnicodeSupport = false;
 }
 
-bool CUpDownClient::ProcessHelloPacket(const byte* pachPacket, uint32 nSize)
+bool CUpDownClient::ProcessHelloPacket(const mule_byte* pachPacket, uint32 nSize)
 {
 	const CMemFile data(pachPacket,nSize);
 	uint8 hashsize = data.ReadUInt8();
@@ -459,7 +459,7 @@ void CUpDownClient::Safe_Delete()
 }
 
 
-bool CUpDownClient::ProcessHelloAnswer(const byte* pachPacket, uint32 nSize)
+bool CUpDownClient::ProcessHelloAnswer(const mule_byte* pachPacket, uint32 nSize)
 {
 	const CMemFile data(pachPacket,nSize);
 	bool bIsMule = ProcessHelloTypePacket(data);
@@ -840,7 +840,7 @@ void CUpDownClient::SendMuleInfoPacket(bool bAnswer, bool OSInfo)
 	}
 }
 
-bool CUpDownClient::ProcessMuleInfoPacket(const byte* pachPacket, uint32 nSize)
+bool CUpDownClient::ProcessMuleInfoPacket(const mule_byte* pachPacket, uint32 nSize)
 {
 	uint8 protocol_version;
 
@@ -1173,7 +1173,7 @@ void CUpDownClient::SendHelloTypePacket(CMemFile* data)
 }
 
 
-void CUpDownClient::ProcessMuleCommentPacket(const byte* pachPacket, uint32 nSize)
+void CUpDownClient::ProcessMuleCommentPacket(const mule_byte* pachPacket, uint32 nSize)
 {
 	if (!m_reqfile) {
 		throw CInvalidPacket(wxT("Comment packet for unknown file"));
@@ -1978,7 +1978,7 @@ void CUpDownClient::RequestSharedFileList()
 }
 
 
-void CUpDownClient::ProcessSharedFileList(const byte* pachPacket, uint32 nSize, wxString& pszDirectory)
+void CUpDownClient::ProcessSharedFileList(const mule_byte* pachPacket, uint32 nSize, wxString& pszDirectory)
 {
 	if (m_iFileListRequested > 0) {
 		m_iFileListRequested--;
@@ -2104,7 +2104,7 @@ void CUpDownClient::SendSignaturePacket()
 		}
 	}
 	//end v2
-	byte achBuffer[250];
+	mule_byte achBuffer[250];
 
 	uint8 siglen = theApp->clientcredits->CreateSignature(credits, achBuffer,  250, ChallengeIP, byChaIPKind );
 	wxCHECK2(siglen != 0, return);
@@ -2125,7 +2125,7 @@ void CUpDownClient::SendSignaturePacket()
 }
 
 
-void CUpDownClient::ProcessPublicKeyPacket(const byte* pachPacket, uint32 nSize)
+void CUpDownClient::ProcessPublicKeyPacket(const mule_byte* pachPacket, uint32 nSize)
 {
 	theApp->clientlist->AddTrackClient(this);
 
@@ -2161,7 +2161,7 @@ void CUpDownClient::ProcessPublicKeyPacket(const byte* pachPacket, uint32 nSize)
 }
 
 
-void CUpDownClient::ProcessSignaturePacket(const byte* pachPacket, uint32 nSize)
+void CUpDownClient::ProcessSignaturePacket(const mule_byte* pachPacket, uint32 nSize)
 {
 	// here we spread the good guys from the bad ones ;)
 
@@ -2249,7 +2249,7 @@ void CUpDownClient::SendSecIdentStatePacket()
 }
 
 
-void CUpDownClient::ProcessSecIdentStatePacket(const byte* pachPacket, uint32 nSize)
+void CUpDownClient::ProcessSecIdentStatePacket(const mule_byte* pachPacket, uint32 nSize)
 {
 	if ( nSize != 5 ) {
 		return;
@@ -2345,7 +2345,7 @@ void CUpDownClient::SendPublicIPRequest()
 	}
 }
 
-void CUpDownClient::ProcessPublicIPAnswer(const byte* pbyData, uint32 uSize)
+void CUpDownClient::ProcessPublicIPAnswer(const mule_byte* pbyData, uint32 uSize)
 {
 	if (uSize != 4) {
 		throw wxString(wxT("Wrong Packet size on Public IP answer"));
@@ -2528,7 +2528,7 @@ bool CUpDownClient::SendChatMessage(const wxString& message)
 
 /* Kad stuff */
 
-void CUpDownClient::SetBuddyID(const byte* pucBuddyID)
+void CUpDownClient::SetBuddyID(const mule_byte* pucBuddyID)
 {
 	if( pucBuddyID == NULL ){
 		md4clr(m_achBuddyID);
@@ -2723,7 +2723,7 @@ void CUpDownClient::ProcessChatMessage(wxString message)
 							m_strCaptchaChallenge = captcha.GetCaptchaText();
 							m_nChatCaptchaState = CA_CHALLENGESENT;
 							m_cCaptchasSent++;
-							CMemFile fileAnswer((byte*) memstr.GetOutputStreamBuffer()->GetBufferStart(), memstr.GetLength());
+							CMemFile fileAnswer((mule_byte*) memstr.GetOutputStreamBuffer()->GetBufferStart(), memstr.GetLength());
 							CPacket* packet = new CPacket(fileAnswer, OP_EMULEPROT, OP_CHATCAPTCHAREQ);
 							theStats::AddUpOverheadOther(packet->GetPacketSize());
 							AddLogLineN(CFormat(wxT("sent Captcha %s (%d)")) % m_strCaptchaChallenge % packet->GetPacketSize());
@@ -2757,7 +2757,7 @@ void CUpDownClient::ProcessChatMessage(wxString message)
 					m_cCaptchasSent = 0;
 					m_strCaptchaChallenge.Clear();
 					CPacket* packet = new CPacket(OP_CHATCAPTCHARES, 1, OP_EMULEPROT, false);
-					byte statusResponse = 0; // status response
+					mule_byte statusResponse = 0; // status response
 					packet->CopyToDataBuffer(0, &statusResponse, 1);
 					theStats::AddUpOverheadOther(packet->GetPacketSize());
 					SafeSendPacket(packet);
@@ -2767,7 +2767,7 @@ void CUpDownClient::ProcessChatMessage(wxString message)
 					m_strCaptchaChallenge.Clear();
 					m_strCaptchaPendingMsg.Clear();
 					CPacket* packet = new CPacket(OP_CHATCAPTCHARES, 1, OP_EMULEPROT, false);
-					byte statusResponse = (m_cCaptchasSent < 3) ? 1 : 2; // status response
+					mule_byte statusResponse = (m_cCaptchasSent < 3) ? 1 : 2; // status response
 					packet->CopyToDataBuffer(0, &statusResponse, 1);
 					theStats::AddUpOverheadOther(packet->GetPacketSize());
 					SafeSendPacket(packet);
diff --git a/src/ClientCredits.cpp b/src/ClientCredits.cpp
index 2804292d7..ee165add2 100644
--- a/src/ClientCredits.cpp
+++ b/src/ClientCredits.cpp
@@ -205,7 +205,7 @@ void CClientCredits::Verified(uint32 dwForIP)
 }
 
 
-bool CClientCredits::SetSecureIdent(const byte* pachIdent, uint8 nIdentLen)
+bool CClientCredits::SetSecureIdent(const mule_byte* pachIdent, uint8 nIdentLen)
 { // verified Public key cannot change, use only if there is not public key yet
 	if (MAXPUBKEYSIZE < nIdentLen || m_pCredits->nKeySize != 0 ) {
 		return false;
diff --git a/src/ClientCredits.h b/src/ClientCredits.h
index ae194c2b8..b08d4e7e4 100644
--- a/src/ClientCredits.h
+++ b/src/ClientCredits.h
@@ -45,7 +45,7 @@ class CreditStruct
 	uint32		nLastSeen;
 	uint16		nReserved3;
 	uint8		nKeySize;
-	byte		abySecureIdent[MAXPUBKEYSIZE];
+	mule_byte	abySecureIdent[MAXPUBKEYSIZE];
 };
 
 enum EIdentState{
@@ -65,7 +65,7 @@ class CClientCredits
 	~CClientCredits();
 
 	const CMD4Hash& GetKey() const			{return m_pCredits->key;}
-	const byte*	GetSecureIdent() const	{return m_abyPublicKey;}
+	const mule_byte*	GetSecureIdent() const	{return m_abyPublicKey;}
 	uint8	GetSecIDKeyLen() const			{return m_nPublicKeyLen;}
 	const CreditStruct* GetDataStruct() const	{return m_pCredits;}
 	void	ClearWaitStartTime();
@@ -75,7 +75,7 @@ class CClientCredits
 	uint64	GetDownloadedTotal() const;
 	float	GetScoreRatio(uint32 dwForIP, bool cryptoavail);
 	void	SetLastSeen();
-	bool	SetSecureIdent(const byte* pachIdent, uint8 nIdentLen); // Public key cannot change, use only if there is not public key yet
+	bool	SetSecureIdent(const mule_byte* pachIdent, uint8 nIdentLen); // Public key cannot change, use only if there is not public key yet
 	uint32	m_dwCryptRndChallengeFor;
 	uint32	m_dwCryptRndChallengeFrom;
 	EIdentState	GetCurrentIdentState(uint32 dwForIP) const; // can be != m_identState
@@ -88,8 +88,8 @@ class CClientCredits
 private:
 	EIdentState		m_identState;
 	void			InitalizeIdent();
-	CreditStruct*	m_pCredits;
-	byte			m_abyPublicKey[80];			// even keys which are not verified will be stored here, and - if verified - copied into the struct
+	CreditStruct*		m_pCredits;
+	mule_byte		m_abyPublicKey[80];			// even keys which are not verified will be stored here, and - if verified - copied into the struct
 	uint8			m_nPublicKeyLen;
 	uint32			m_dwIdentIP;
 	uint32			m_dwSecureWaitTime;
diff --git a/src/ClientCreditsList.cpp b/src/ClientCreditsList.cpp
index 69e881fd8..c5da907d9 100644
--- a/src/ClientCreditsList.cpp
+++ b/src/ClientCreditsList.cpp
@@ -326,7 +326,7 @@ void CClientCreditsList::InitalizeCrypting()
 }
 
 
-uint8 CClientCreditsList::CreateSignature(CClientCredits* pTarget, byte* pachOutput, uint8 nMaxSize, uint32 ChallengeIP, uint8 byChaIPKind, void* sigkey)
+uint8 CClientCreditsList::CreateSignature(CClientCredits* pTarget, mule_byte* pachOutput, uint8 nMaxSize, uint32 ChallengeIP, uint8 byChaIPKind, void* sigkey)
 {
 	CryptoPP::RSASSA_PKCS1v15_SHA_Signer* signer =
 		static_cast<CryptoPP::RSASSA_PKCS1v15_SHA_Signer *>(sigkey);
@@ -345,7 +345,7 @@ uint8 CClientCreditsList::CreateSignature(CClientCredits* pTarget, byte* pachOut
 	try {
 		CryptoPP::SecByteBlock sbbSignature(signer->SignatureLength());
 		CryptoPP::AutoSeededX917RNG<CryptoPP::DES_EDE3> rng;
-		byte abyBuffer[MAXPUBKEYSIZE+9];
+		CryptoPP::byte abyBuffer[MAXPUBKEYSIZE+9];
 		uint32 keylen = pTarget->GetSecIDKeyLen();
 		memcpy(abyBuffer,pTarget->GetSecureIdent(),keylen);
 		// 4 additional bytes random data send from this client
@@ -373,7 +373,7 @@ uint8 CClientCreditsList::CreateSignature(CClientCredits* pTarget, byte* pachOut
 }
 
 
-bool CClientCreditsList::VerifyIdent(CClientCredits* pTarget, const byte* pachSignature, uint8 nInputSize, uint32 dwForIP, uint8 byChaIPKind)
+bool CClientCreditsList::VerifyIdent(CClientCredits* pTarget, const CryptoPP::byte* pachSignature, uint8 nInputSize, uint32 dwForIP, uint8 byChaIPKind)
 {
 	wxASSERT( pTarget );
 	wxASSERT( pachSignature );
@@ -383,10 +383,10 @@ bool CClientCreditsList::VerifyIdent(CClientCredits* pTarget, const byte* pachSi
 	}
 	bool bResult;
 	try {
-		CryptoPP::StringSource ss_Pubkey((byte*)pTarget->GetSecureIdent(),pTarget->GetSecIDKeyLen(),true,0);
+		CryptoPP::StringSource ss_Pubkey((CryptoPP::byte*)pTarget->GetSecureIdent(),pTarget->GetSecIDKeyLen(),true,0);
 		CryptoPP::RSASSA_PKCS1v15_SHA_Verifier pubkey(ss_Pubkey);
 		// 4 additional bytes random data send from this client +5 bytes v2
-		byte abyBuffer[MAXPUBKEYSIZE+9];
+		CryptoPP::byte abyBuffer[MAXPUBKEYSIZE+9];
 		memcpy(abyBuffer,m_abyMyPublicKey,m_nMyPublicKeyLen);
 		uint32 challenge = pTarget->m_dwCryptRndChallengeFor;
 		wxASSERT ( challenge != 0 );
@@ -455,7 +455,7 @@ bool CClientCreditsList::Debug_CheckCrypting(){
 	CryptoPP::RSASSA_PKCS1v15_SHA_Signer priv(rng, 384);
 	CryptoPP::RSASSA_PKCS1v15_SHA_Verifier pub(priv);
 
-	byte abyPublicKey[80];
+	CryptoPP::byte abyPublicKey[80];
 	CryptoPP::ArraySink asink(abyPublicKey, 80);
 	pub.DEREncode(asink);
 	int8 PublicKeyLen = asink.TotalPutLength();
@@ -467,7 +467,7 @@ bool CClientCreditsList::Debug_CheckCrypting(){
 	newcredits.SetSecureIdent(m_abyMyPublicKey,m_nMyPublicKeyLen);
 	newcredits.m_dwCryptRndChallengeFrom = challenge;
 	// create signature with fake priv key
-	byte pachSignature[200];
+	CryptoPP::byte pachSignature[200];
 	memset(pachSignature,0,200);
 	uint8 sigsize = CreateSignature(&newcredits,pachSignature,200,0,false, &priv);
 
diff --git a/src/ClientCreditsList.h b/src/ClientCreditsList.h
index 3b3aa6c46..fd5c7ce47 100644
--- a/src/ClientCreditsList.h
+++ b/src/ClientCreditsList.h
@@ -39,13 +39,13 @@ class CClientCreditsList
 	~CClientCreditsList();
 
 	// return signature size, 0 = Failed | use sigkey param for debug only
-	uint8	CreateSignature(CClientCredits* pTarget, byte* pachOutput, uint8 nMaxSize, uint32 ChallengeIP, uint8 byChaIPKind, void* sigkey = NULL);
-	bool	VerifyIdent(CClientCredits* pTarget, const byte* pachSignature, uint8 nInputSize, uint32 dwForIP, uint8 byChaIPKind);
+	uint8	CreateSignature(CClientCredits* pTarget, mule_byte* pachOutput, uint8 nMaxSize, uint32 ChallengeIP, uint8 byChaIPKind, void* sigkey = NULL);
+	bool	VerifyIdent(CClientCredits* pTarget, const mule_byte* pachSignature, uint8 nInputSize, uint32 dwForIP, uint8 byChaIPKind);
 
 	CClientCredits* GetCredit(const CMD4Hash& key);
 	void	Process();
 	uint8	GetPubKeyLen() const			{return m_nMyPublicKeyLen;}
-	const byte*	GetPublicKey() const		{return m_abyMyPublicKey;}
+	const mule_byte*	GetPublicKey() const	{return m_abyMyPublicKey;}
 	bool	CryptoAvailable() const;
 	void	SaveList();
 protected:
@@ -61,7 +61,7 @@ class CClientCreditsList
 	uint32		m_nLastSaved;
 	// A void* to avoid having to include the large CryptoPP.h file
 	void*		m_pSignkey;
-	byte		m_abyMyPublicKey[80];
+	mule_byte	m_abyMyPublicKey[80];
 	uint8		m_nMyPublicKeyLen;
 };
 
diff --git a/src/ClientList.cpp b/src/ClientList.cpp
index f26cce434..b607d7d89 100644
--- a/src/ClientList.cpp
+++ b/src/ClientList.cpp
@@ -923,7 +923,7 @@ bool CClientList::IncomingBuddy(Kademlia::CContact* contact, Kademlia::CUInt128*
 	CUpDownClient* pNewClient = new CUpDownClient(contact->GetTCPPort(), contact->GetIPAddress(), 0, 0, NULL, false, true );
 	pNewClient->SetKadPort(contact->GetUDPPort());
 	pNewClient->SetKadState(KS_INCOMING_BUDDY);
-	byte ID[16];
+	mule_byte ID[16];
 	contact->GetClientID().ToByteArray(ID);
 	pNewClient->SetUserHash(CMD4Hash(ID));
 	buddyID->ToByteArray(ID);
diff --git a/src/ClientTCPSocket.cpp b/src/ClientTCPSocket.cpp
index 9cf787925..b38ca6fb4 100644
--- a/src/ClientTCPSocket.cpp
+++ b/src/ClientTCPSocket.cpp
@@ -298,7 +298,7 @@ void CClientTCPSocket::Safe_Delete_Client()
 }
 
 
-bool CClientTCPSocket::ProcessPacket(const byte* buffer, uint32 size, uint8 opcode)
+bool CClientTCPSocket::ProcessPacket(const mule_byte* buffer, uint32 size, uint8 opcode)
 {
 	#ifdef __PACKET_RECV_DUMP__
 	//printf("Rec: OPCODE %x \n",opcode);
@@ -1016,7 +1016,7 @@ bool CClientTCPSocket::ProcessPacket(const byte* buffer, uint32 size, uint8 opco
 }
 
 
-bool CClientTCPSocket::ProcessExtPacket(const byte* buffer, uint32 size, uint8 opcode)
+bool CClientTCPSocket::ProcessExtPacket(const mule_byte* buffer, uint32 size, uint8 opcode)
 {
 	#ifdef __PACKET_RECV_DUMP__
 	//printf("Rec: OPCODE %x \n",opcode);
@@ -1640,7 +1640,7 @@ bool CClientTCPSocket::ProcessExtPacket(const byte* buffer, uint32 size, uint8 o
 				break;
 			}
 			CUInt128 fileid = data.ReadUInt128();
-			byte fileid2[16];
+			mule_byte fileid2[16];
 			fileid.ToByteArray(fileid2);
 			const CMD4Hash fileHash(fileid2);
 			if (theApp->sharedfiles->GetFileByID(fileHash) == NULL) {
@@ -1819,7 +1819,7 @@ bool CClientTCPSocket::ProcessExtPacket(const byte* buffer, uint32 size, uint8 o
 	return true;
 }
 
-bool CClientTCPSocket::ProcessED2Kv2Packet(const byte* buffer, uint32 size, uint8 opcode)
+bool CClientTCPSocket::ProcessED2Kv2Packet(const mule_byte* buffer, uint32 size, uint8 opcode)
 {
 	#ifdef __PACKET_RECV_DUMP__
 	//printf("Rec: OPCODE %x ED2Kv2\n",opcode);
diff --git a/src/ClientTCPSocket.h b/src/ClientTCPSocket.h
index ba65265a8..9858d699c 100644
--- a/src/ClientTCPSocket.h
+++ b/src/ClientTCPSocket.h
@@ -78,9 +78,9 @@ class CClientTCPSocket : public CEMSocket
 private:
 	CUpDownClient*	m_client;
 
-	bool	ProcessPacket(const byte* packet, uint32 size, uint8 opcode);
-	bool	ProcessExtPacket(const byte* packet, uint32 size, uint8 opcode);
-	bool	ProcessED2Kv2Packet(const byte* packet, uint32 size, uint8 opcode);
+	bool	ProcessPacket(const mule_byte* packet, uint32 size, uint8 opcode);
+	bool	ProcessExtPacket(const mule_byte* packet, uint32 size, uint8 opcode);
+	bool	ProcessED2Kv2Packet(const mule_byte* packet, uint32 size, uint8 opcode);
 	void	ResetTimeOutTimer();
 	void	SetClient(CUpDownClient* client);
 
diff --git a/src/ClientUDPSocket.cpp b/src/ClientUDPSocket.cpp
index 924363a33..65a83b2e9 100644
--- a/src/ClientUDPSocket.cpp
+++ b/src/ClientUDPSocket.cpp
@@ -75,7 +75,7 @@ void CClientUDPSocket::OnReceive(int errorCode)
 }
 
 
-void CClientUDPSocket::OnPacketReceived(uint32 ip, uint16 port, byte* buffer, size_t length)
+void CClientUDPSocket::OnPacketReceived(uint32 ip, uint16 port, mule_byte* buffer, size_t length)
 {
 	wxCHECK_RET(length >= 2, wxT("Invalid packet."));
 
@@ -137,7 +137,7 @@ void CClientUDPSocket::OnPacketReceived(uint32 ip, uint16 port, byte* buffer, si
 }
 
 
-void CClientUDPSocket::ProcessPacket(byte* packet, int16 size, int8 opcode, uint32 host, uint16 port)
+void CClientUDPSocket::ProcessPacket(mule_byte* packet, int16 size, int8 opcode, uint32 host, uint16 port)
 {
 	switch (opcode) {
 		case OP_REASKCALLBACKUDP: {
diff --git a/src/ClientUDPSocket.h b/src/ClientUDPSocket.h
index 162acaaf6..e42e4253c 100644
--- a/src/ClientUDPSocket.h
+++ b/src/ClientUDPSocket.h
@@ -37,8 +37,8 @@ class CClientUDPSocket : public CMuleUDPSocket
 	void	OnReceive(int errorCode);
 
 private:
-	void	OnPacketReceived(uint32 ip, uint16 port, byte* buffer, size_t length);
-	void	ProcessPacket(byte* packet, int16 size, int8 opcode, uint32 host, uint16 port);
+	void	OnPacketReceived(uint32 ip, uint16 port, mule_byte* buffer, size_t length);
+	void	ProcessPacket(mule_byte* packet, int16 size, int8 opcode, uint32 host, uint16 port);
 };
 
 #endif // CLIENTUDPSOCKET_H
diff --git a/src/DownloadClient.cpp b/src/DownloadClient.cpp
index c364f7428..bc489f3c1 100644
--- a/src/DownloadClient.cpp
+++ b/src/DownloadClient.cpp
@@ -568,7 +568,7 @@ void CUpDownClient::SetDownloadState(uint8 byNewState)
 }
 /* eMule 0.30c implementation, i give it a try (Creteil) END ... */
 
-void CUpDownClient::ProcessHashSet(const byte* packet, uint32 size)
+void CUpDownClient::ProcessHashSet(const mule_byte* packet, uint32 size)
 {
 	if ((!m_reqfile) || md4cmp(packet,m_reqfile->GetFileHash().GetHash())) {
 		throw wxString(wxT("Wrong fileid sent (ProcessHashSet)"));
@@ -830,7 +830,7 @@ The requests will still not exceed 180k, but may be smaller to
 fill a gap.
 */
 
-void CUpDownClient::ProcessBlockPacket(const byte* packet, uint32 size, bool packed, bool largeblocks)
+void CUpDownClient::ProcessBlockPacket(const mule_byte* packet, uint32 size, bool packed, bool largeblocks)
 {
 	// Ignore if no data required
 	if (!(GetDownloadState() == DS_DOWNLOADING || GetDownloadState() == DS_NONEEDEDPARTS)) {
@@ -930,7 +930,7 @@ void CUpDownClient::ProcessBlockPacket(const byte* packet, uint32 size, bool pac
 						return;
 					}
 					// Write to disk (will be buffered in part file class)
-					lenWritten = m_reqfile->WriteToBuffer( size - header_size, (byte*)(packet + header_size), nStartPos, nEndPos, cur_block->block, this);
+					lenWritten = m_reqfile->WriteToBuffer( size - header_size, (mule_byte*)(packet + header_size), nStartPos, nEndPos, cur_block->block, this);
 				} else {
 					// Packed
 					wxASSERT( (long int)size > 0 );
@@ -942,10 +942,10 @@ void CUpDownClient::ProcessBlockPacket(const byte* packet, uint32 size, bool pac
 					if (lenUnzipped > (BLOCKSIZE + 300)) {
 						lenUnzipped = (BLOCKSIZE + 300);
 					}
-					byte *unzipped = new byte[lenUnzipped];
+					mule_byte *unzipped = new mule_byte[lenUnzipped];
 
 					// Try to unzip the packet
-					int result = unzip(cur_block, (byte*)(packet + header_size), (size - header_size), &unzipped, &lenUnzipped);
+					int result = unzip(cur_block, (mule_byte*)(packet + header_size), (size - header_size), &unzipped, &lenUnzipped);
 
 					// no block can be uncompressed to >2GB, 'lenUnzipped' is obviously erroneous.
 					if (result == Z_OK && ((int)lenUnzipped >= 0)) {
@@ -1046,7 +1046,7 @@ void CUpDownClient::ProcessBlockPacket(const byte* packet, uint32 size, bool pac
 	}
 }
 
-int CUpDownClient::unzip(Pending_Block_Struct *block, byte *zipped, uint32 lenZipped, byte **unzipped, uint32 *lenUnzipped, int iRecursion)
+int CUpDownClient::unzip(Pending_Block_Struct *block, mule_byte *zipped, uint32 lenZipped, mule_byte **unzipped, uint32 *lenUnzipped, int iRecursion)
 {
 	int err = Z_DATA_ERROR;
 
@@ -1112,7 +1112,7 @@ int CUpDownClient::unzip(Pending_Block_Struct *block, byte *zipped, uint32 lenZi
 			newLength = lenZipped * 2;
 		}
 		// Copy any data that was successfully unzipped to new array
-		byte *temp = new byte[newLength];
+		mule_byte *temp = new mule_byte[newLength];
 		wxASSERT( zS->total_out - block->totalUnzipped <= newLength );
 		memcpy(temp, (*unzipped), (zS->total_out - block->totalUnzipped));
 		delete [] (*unzipped);
@@ -1601,7 +1601,7 @@ void CUpDownClient::SendAICHRequest(CPartFile* pForFile, uint16 nPart){
 	SafeSendPacket(packet);
 }
 
-void CUpDownClient::ProcessAICHAnswer(const byte* packet, uint32 size)
+void CUpDownClient::ProcessAICHAnswer(const mule_byte* packet, uint32 size)
 {
 	if (m_fAICHRequested == FALSE){
 		throw wxString(wxT("Received unrequested AICH Packet"));
@@ -1643,7 +1643,7 @@ void CUpDownClient::ProcessAICHAnswer(const byte* packet, uint32 size)
 }
 
 
-void CUpDownClient::ProcessAICHRequest(const byte* packet, uint32 size)
+void CUpDownClient::ProcessAICHRequest(const mule_byte* packet, uint32 size)
 {
 	if (size != 16 + 2 + CAICHHash::GetHashSize()) {
 		throw wxString(wxT("Received AICH Request Packet with wrong size"));
diff --git a/src/DownloadQueue.cpp b/src/DownloadQueue.cpp
index 6a4eb2221..2a15f2666 100644
--- a/src/DownloadQueue.cpp
+++ b/src/DownloadQueue.cpp
@@ -1114,7 +1114,7 @@ void CDownloadQueue::ProcessLocalRequests()
 		if (iSize > 0) {
 			// create one 'packet' which contains all buffered OP_GETSOURCES ED2K packets to be sent with one TCP frame
 			// server credits: (16+4)*regularfiles + (16+4+8)*largefiles +1
-			CScopedPtr<CPacket> packet(new CPacket(new byte[iSize], dataTcpFrame.GetLength(), true, false));
+			CScopedPtr<CPacket> packet(new CPacket(new mule_byte[iSize], dataTcpFrame.GetLength(), true, false));
 			dataTcpFrame.Seek(0, wxFromStart);
 			dataTcpFrame.Read(packet->GetPacket(), iSize);
 			uint32 size = packet->GetPacketSize();
@@ -1591,7 +1591,7 @@ void CDownloadQueue::KademliaSearchFile(uint32_t searchID, const Kademlia::CUInt
 			//ctemp->SetServerIP(serverip);
 			//ctemp->SetServerPort(serverport);
 			ctemp->SetKadPort(udp);
-			byte cID[16];
+			mule_byte cID[16];
 			pcontactID->ToByteArray(cID);
 			ctemp->SetUserHash(CMD4Hash(cID));
 			break;
@@ -1609,7 +1609,7 @@ void CDownloadQueue::KademliaSearchFile(uint32_t searchID, const Kademlia::CUInt
 			// from this firewalled source, the compare method will match them.
 			ctemp->SetSourceFrom(SF_KADEMLIA);
 			ctemp->SetKadPort(udp);
-			byte cID[16];
+			mule_byte cID[16];
 			pcontactID->ToByteArray(cID);
 			ctemp->SetUserHash(CMD4Hash(cID));
 			pbuddyID->ToByteArray(cID);
@@ -1634,7 +1634,7 @@ void CDownloadQueue::KademliaSearchFile(uint32_t searchID, const Kademlia::CUInt
 			ctemp->SetSourceFrom(SF_KADEMLIA);
 			ctemp->SetKadPort(udp);
 			ctemp->SetIP(ED2KID); // need to set the IP address, which cannot be used for TCP but for UDP
-			byte cID[16];
+			mule_byte cID[16];
 			pcontactID->ToByteArray(cID);
 			ctemp->SetUserHash(CMD4Hash(cID));
 		}
diff --git a/src/EMSocket.cpp b/src/EMSocket.cpp
index 3ccaa7ea1..376573d9e 100644
--- a/src/EMSocket.cpp
+++ b/src/EMSocket.cpp
@@ -199,7 +199,7 @@ void CEMSocket::OnReceive(int nErrorCode)
 		}
 
 		uint32 readMax;
-		byte *buf;
+		mule_byte *buf;
 		if (pendingHeaderSize < PACKET_HEADER_SIZE) {
 			delete[] pendingPacket;
 			pendingPacket = NULL;
@@ -213,7 +213,7 @@ void CEMSocket::OnReceive(int nErrorCode)
 				OnError(ERR_TOOBIG);
 				return;
 			}
-			pendingPacket = new byte[readMax + 1];
+			pendingPacket = new mule_byte[readMax + 1];
 			buf = pendingPacket;
 		} else {
 			buf = pendingPacket + pendingPacketSize;
@@ -529,7 +529,7 @@ SocketSentBytes CEMSocket::Send(uint32 maxNumberOfBytesToSend, uint32 minFragSiz
 				sent = 0;
 				delete curPacket;
 
-				CryptPrepareSendData((byte*)sendbuffer, sendblen);
+				CryptPrepareSendData((mule_byte*)sendbuffer, sendblen);
 			}
 
 			// At this point we've got a packet to send in sendbuffer. Try to send it. Loop until entire packet
diff --git a/src/EMSocket.h b/src/EMSocket.h
index 4d00361ee..0aede86cc 100644
--- a/src/EMSocket.h
+++ b/src/EMSocket.h
@@ -99,17 +99,17 @@ class CEMSocket : public CEncryptedStreamSocket, public ThrottledFileSocket
 	bool	pendingOnReceive;
 
 	// Download partial header
-	byte	pendingHeader[PACKET_HEADER_SIZE];
-	uint32	pendingHeaderSize;
+	mule_byte	pendingHeader[PACKET_HEADER_SIZE];
+	uint32		pendingHeaderSize;
 
 	// Download partial packet
-	byte*	pendingPacket;
-	uint32  pendingPacketSize;
+	mule_byte*	pendingPacket;
+	uint32  	pendingPacketSize;
 
 	// Upload control
-	byte*	sendbuffer;
-	uint32	sendblen;
-	uint32	sent;
+	mule_byte*	sendbuffer;
+	uint32		sendblen;
+	uint32		sent;
 
 	typedef std::list<CPacket*> CPacketQueue;
 	CPacketQueue m_control_queue;
diff --git a/src/EncryptedStreamSocket.cpp b/src/EncryptedStreamSocket.cpp
index 408c26469..9e72a7005 100644
--- a/src/EncryptedStreamSocket.cpp
+++ b/src/EncryptedStreamSocket.cpp
@@ -403,7 +403,7 @@ void CEncryptedStreamSocket::StartNegotiation(bool bOutgoing)
 
 		m_cryptDHA.Randomize((CryptoPP::AutoSeededRandomPool&)GetRandomPool(), DHAGREEMENT_A_BITS); // our random a
 		wxASSERT( m_cryptDHA.MinEncodedSize() <= DHAGREEMENT_A_BITS / 8 );
-		CryptoPP::Integer cryptDHPrime((byte*)dh768_p, PRIMESIZE_BYTES);  // our fixed prime
+		CryptoPP::Integer cryptDHPrime((CryptoPP::byte*)dh768_p, PRIMESIZE_BYTES);  // our fixed prime
 		// calculate g^a % p
 		CryptoPP::Integer cryptDHGexpAmodP = a_exp_b_mod_c(CryptoPP::Integer(2), m_cryptDHA, cryptDHPrime);
 		wxASSERT( m_cryptDHA.MinEncodedSize() <= PRIMESIZE_BYTES );
@@ -592,8 +592,8 @@ int CEncryptedStreamSocket::Negotiate(const uint8* pBuffer, uint32 nLen)
 					wxASSERT( !m_cryptDHA.IsZero() );
 					uint8_t aBuffer[PRIMESIZE_BYTES + 1];
 					m_pfiReceiveBuffer.Read(aBuffer, PRIMESIZE_BYTES);
-					CryptoPP::Integer cryptDHAnswer((byte*)aBuffer, PRIMESIZE_BYTES);
-					CryptoPP::Integer cryptDHPrime((byte*)dh768_p, PRIMESIZE_BYTES);  // our fixed prime
+					CryptoPP::Integer cryptDHAnswer((CryptoPP::byte*)aBuffer, PRIMESIZE_BYTES);
+					CryptoPP::Integer cryptDHPrime((CryptoPP::byte*)dh768_p, PRIMESIZE_BYTES);  // our fixed prime
 					CryptoPP::Integer cryptResult = a_exp_b_mod_c(cryptDHAnswer, m_cryptDHA, cryptDHPrime);
 
 					m_cryptDHA = 0;
diff --git a/src/FileArea.cpp b/src/FileArea.cpp
index be8e13864..ea0e2f84f 100644
--- a/src/FileArea.cpp
+++ b/src/FileArea.cpp
@@ -232,7 +232,7 @@ void CFileArea::ReadAt(CFileAutoClose& file, uint64 offset, size_t count)
 		void *p = mmap(NULL, m_length, PROT_READ, MAP_SHARED, file.fd(), offStart);
 		if (p != MAP_FAILED) {
 			m_file = &file;
-			m_mmap_buffer = (byte*) p;
+			m_mmap_buffer = (mule_byte*) p;
 			m_buffer = m_mmap_buffer + (offset - offStart);
 
 			// add to list to catch errors correctly
@@ -242,7 +242,7 @@ void CFileArea::ReadAt(CFileAutoClose& file, uint64 offset, size_t count)
 	}
 	file.Unlock();
 #endif
-	m_buffer = new byte[count];
+	m_buffer = new mule_byte[count];
 	file.ReadAt(m_buffer, offset, count);
 }
 
@@ -259,7 +259,7 @@ void CFileArea::StartWriteAt(CFileAutoClose& file, uint64 offset, size_t count)
 		if (p != MAP_FAILED)
 		{
 			m_file = &file;
-			m_mmap_buffer = (byte*) p;
+			m_mmap_buffer = (mule_byte*) p;
 			m_buffer = m_mmap_buffer + (offset - offStart);
 
 			// add to list to catch errors correctly
@@ -268,13 +268,13 @@ void CFileArea::StartWriteAt(CFileAutoClose& file, uint64 offset, size_t count)
 		}
 		file.Unlock();
 	}
-	m_buffer = new byte[count];
+	m_buffer = new mule_byte[count];
 }
 #else
 void CFileArea::StartWriteAt(CFileAutoClose&, uint64, size_t count)
 {
 	Close();
-	m_buffer = new byte[count];
+	m_buffer = new mule_byte[count];
 }
 #endif
 
diff --git a/src/FileArea.h b/src/FileArea.h
index 400615177..0e3d1d6dc 100644
--- a/src/FileArea.h
+++ b/src/FileArea.h
@@ -22,7 +22,7 @@
 #ifndef FILEAREA_H
 #define FILEAREA_H
 
-#include "Types.h"		// Needed for byte
+#include "Types.h"		// Needed for mule_byte
 
 class CFileAreaSigHandler;
 class CFileAutoClose;
@@ -78,7 +78,7 @@ friend class CFileAreaSigHandler;
 	 * Get buffer that contains data readed or to write.
 	 * @return allocated buffer or NULL if not initialized
 	 */
-	byte *GetBuffer() const { return m_buffer; };
+	mule_byte *GetBuffer() const { return m_buffer; };
 
 	/**
 	 * Report error pending
@@ -97,11 +97,11 @@ friend class CFileAreaSigHandler;
 	 * If mapped points inside m_mmap_buffer area otherwise
 	 * point to an allocated buffer to be freed.
 	 */
-	byte *m_buffer;
+	mule_byte *m_buffer;
 	/**
 	 * Pointer to memory mapped area or NULL if not mapped.
 	 */
-	byte *m_mmap_buffer;
+	mule_byte *m_mmap_buffer;
 	/**
 	 * Length of the mapped region, currently used only for munmap.
 	 */
diff --git a/src/GapList.h b/src/GapList.h
index 41c4af718..d104c0c40 100644
--- a/src/GapList.h
+++ b/src/GapList.h
@@ -52,7 +52,7 @@ class CGapList {
 		incomplete,
 		unknown
 	};
-	std::vector<byte> m_partsComplete;
+	std::vector<mule_byte> m_partsComplete;
 
 	// get size of any part
 	uint32 GetPartSize(uint16 part) const { return part == m_iPartCount - 1 ? m_sizeLastPart : PARTSIZE; }
diff --git a/src/KnownFile.cpp b/src/KnownFile.cpp
index 576330060..f53efd2f8 100644
--- a/src/KnownFile.cpp
+++ b/src/KnownFile.cpp
@@ -788,8 +788,8 @@ void CKnownFile::CreateHashFromHashlist(const ArrayOfCMD4Hash& hashes, CMD4Hash*
 {
 	wxCHECK_RET(hashes.size(), wxT("No input to hash from in CreateHashFromHashlist"));
 
-	std::vector<byte> buffer(hashes.size() * MD4HASH_LENGTH);
-	std::vector<byte>::iterator it = buffer.begin();
+	std::vector<mule_byte> buffer(hashes.size() * MD4HASH_LENGTH);
+	std::vector<mule_byte>::iterator it = buffer.begin();
 
 	for (size_t i = 0; i < hashes.size(); ++i) {
 		it = STLCopy_n(hashes[i].GetHash(), MD4HASH_LENGTH, it);
@@ -811,7 +811,7 @@ void CKnownFile::CreateHashFromFile(CFileAutoClose& file, uint64 offset, uint32
 }
 
 
-void CKnownFile::CreateHashFromInput(const byte* input, uint32 Length, CMD4Hash* Output, CAICHHashTree* pShaHashOut )
+void CKnownFile::CreateHashFromInput(const mule_byte* input, uint32 Length, CMD4Hash* Output, CAICHHashTree* pShaHashOut )
 {
 	wxASSERT_MSG(Output || pShaHashOut, wxT("Nothing to do in CreateHashFromInput"));
 	{ wxCHECK_RET(input, wxT("No input to hash from in CreateHashFromInput")); }
@@ -820,7 +820,7 @@ void CKnownFile::CreateHashFromInput(const byte* input, uint32 Length, CMD4Hash*
 	CMemFile data(input, Length);
 
 	uint32 Required = Length;
-	byte   X[64*128];
+	mule_byte   X[64*128];
 
 	uint32	posCurrentEMBlock = 0;
 	uint32	nIACHPos = 0;
diff --git a/src/KnownFile.h b/src/KnownFile.h
index 0ef75596d..175f999f6 100644
--- a/src/KnownFile.h
+++ b/src/KnownFile.h
@@ -333,7 +333,7 @@ friend class CHashingTask;
 	CPath	m_filePath;
 
 	static void CreateHashFromFile(class CFileAutoClose& file, uint64 offset, uint32 Length, CMD4Hash* Output, CAICHHashTree* pShaHashOut);
-	static void CreateHashFromInput(const byte* input, uint32 Length, CMD4Hash* Output, CAICHHashTree* pShaHashOut);
+	static void CreateHashFromInput(const mule_byte* input, uint32 Length, CMD4Hash* Output, CAICHHashTree* pShaHashOut);
 
 	mutable bool	m_bCommentLoaded;
 	uint16	m_iPartCount;
diff --git a/src/MemFile.cpp b/src/MemFile.cpp
index 8796f9b2b..c6e859f92 100644
--- a/src/MemFile.cpp
+++ b/src/MemFile.cpp
@@ -38,7 +38,7 @@ CMemFile::CMemFile(unsigned int growthRate)
 }
 
 
-CMemFile::CMemFile(byte* buffer, size_t bufferSize)
+CMemFile::CMemFile(mule_byte* buffer, size_t bufferSize)
 {
 	MULE_VALIDATE_PARAMS(buffer, wxT("CMemFile: Attempted to attach invalid buffer."));
 
@@ -51,11 +51,11 @@ CMemFile::CMemFile(byte* buffer, size_t bufferSize)
 	m_readonly		= false;
 }
 
-CMemFile::CMemFile(const byte* buffer, size_t bufferSize)
+CMemFile::CMemFile(const mule_byte* buffer, size_t bufferSize)
 {
 	MULE_VALIDATE_PARAMS(buffer, wxT("CMemFile: Attempted to attach invalid buffer."));
 
-	m_buffer		= const_cast<byte*>(buffer);
+	m_buffer		= const_cast<mule_byte*>(buffer);
 	m_BufferSize	= bufferSize;
 	m_fileSize		= bufferSize;
 	m_growthRate	= 0;
@@ -115,7 +115,7 @@ void CMemFile::enlargeBuffer(size_t size)
 		newsize = size;
 	}
 
-	byte *tmp = (byte*)realloc(m_buffer, newsize);
+	mule_byte *tmp = (mule_byte*)realloc(m_buffer, newsize);
 	if (tmp) {
 		m_buffer = tmp;
 		m_BufferSize = newsize;
diff --git a/src/MemFile.h b/src/MemFile.h
index c4f550823..345383c16 100644
--- a/src/MemFile.h
+++ b/src/MemFile.h
@@ -86,10 +86,10 @@ class CMemFile : public CFileDataIO
 	 *
 	 * The buffer is _not_ freed by CMemFile upon destruction.
 	 *
-	 * If the buffer is a const byte*, the memfile is read-only.
+	 * If the buffer is a const mule_byte*, the memfile is read-only.
 	 */
-	CMemFile(byte* buffer, size_t bufferSize);
-	CMemFile(const byte* buffer, size_t bufferSize);
+	CMemFile(mule_byte* buffer, size_t bufferSize);
+	CMemFile(const mule_byte* buffer, size_t bufferSize);
 
 	/** Destructor. */
 	virtual ~CMemFile();
@@ -132,7 +132,7 @@ class CMemFile : public CFileDataIO
 	virtual void ResetData();
 
 	// Sometimes it's useful to get the buffer and do stuff with it.
-	byte* GetRawBuffer() const { return m_buffer; }
+	mule_byte* GetRawBuffer() const { return m_buffer; }
 
 protected:
 	/** @see CFileDataIO::doRead */
@@ -167,7 +167,7 @@ class CMemFile : public CFileDataIO
 	//! read-only mark.
 	bool	m_readonly;
 	//! The actual buffer.
-	byte*	m_buffer;
+	mule_byte*	m_buffer;
 };
 
 #endif // MEMFILE_H
diff --git a/src/MuleColour.h b/src/MuleColour.h
index 1a983ddd6..438289ad4 100644
--- a/src/MuleColour.h
+++ b/src/MuleColour.h
@@ -40,7 +40,7 @@ class CMuleColour
 
 	CMuleColour() { Init(); Set(0,0,0); }
 	CMuleColour(const wxColour& colour) { Init(); Set(colour.Red(), colour.Green(), colour.Blue()); }
-	CMuleColour(byte r, byte g, byte b) { Init(); Set(r,g,b); }
+	CMuleColour(mule_byte r, mule_byte g, mule_byte b) { Init(); Set(r,g,b); }
 	CMuleColour(unsigned long rgb)
 	{
 		Init();
@@ -61,13 +61,13 @@ class CMuleColour
 
 	~CMuleColour() { }
 
-	void Set(byte red, byte green, byte blue) { m_red = red; m_green = green; m_blue = blue; }
+	void Set(mule_byte red, mule_byte green, mule_byte blue) { m_red = red; m_green = green; m_blue = blue; }
 
-	inline byte Red() const { return m_red; }
-	inline byte Green() const { return m_green; }
-	inline byte Blue() const { return m_blue; }
+	inline mule_byte Red() const { return m_red; }
+	inline mule_byte Green() const { return m_green; }
+	inline mule_byte Blue() const { return m_blue; }
 
-	const CMuleColour& Blend(byte percentage, ColourComponent flags = (ColourComponent)(COLOUR_R | COLOUR_G | COLOUR_B) )
+	const CMuleColour& Blend(mule_byte percentage, ColourComponent flags = (ColourComponent)(COLOUR_R | COLOUR_G | COLOUR_B) )
 	{
 		unsigned int red = (unsigned int)(Red() * ((flags & COLOUR_R) ? ((float)percentage/(float)100) : (float)1));
 		unsigned int green = (unsigned int)(Green() * ((flags & COLOUR_G) ? ((float)percentage/(float)100) : (float)1));
@@ -99,9 +99,9 @@ class CMuleColour
 	const wxBrush& GetBrush(int style = wxSOLID) const;
 
 private:
-	byte m_red;
-	byte m_green;
-	byte m_blue;
+	mule_byte m_red;
+	mule_byte m_green;
+	mule_byte m_blue;
 
 	mutable wxPen* m_cachedpen;
 	mutable wxBrush* m_cachedbrush;
diff --git a/src/MuleUDPSocket.cpp b/src/MuleUDPSocket.cpp
index a666c9303..52666a4d7 100644
--- a/src/MuleUDPSocket.cpp
+++ b/src/MuleUDPSocket.cpp
@@ -180,7 +180,7 @@ void CMuleUDPSocket::OnReceive(int errorCode)
 		AddDebugLogLineN(logMuleUDP, (m_name + wxT(": Packet received ("))
 			<< addr.IPAddress() << wxT(":") << port << wxT("): ")
 			<< length << wxT("b"));
-		OnPacketReceived(ip, port, (byte*)buffer, length);
+		OnPacketReceived(ip, port, (mule_byte*)buffer, length);
 	}
 }
 
diff --git a/src/MuleUDPSocket.h b/src/MuleUDPSocket.h
index c9cb023e5..72ab14d90 100644
--- a/src/MuleUDPSocket.h
+++ b/src/MuleUDPSocket.h
@@ -131,7 +131,7 @@ class CMuleUDPSocket : public ThrottledControlSocket
 	 * @param buffer The data that has been received.
 	 * @param length The length of the data buffer.
 	 */
-	virtual void OnPacketReceived(uint32 ip, uint16 port, byte* buffer, size_t length) = 0;
+	virtual void OnPacketReceived(uint32 ip, uint16 port, mule_byte* buffer, size_t length) = 0;
 
 
 	/** See ThrottledControlSocket::SendControlData */
diff --git a/src/OtherFunctions.cpp b/src/OtherFunctions.cpp
index ab84e61a8..d6a0429be 100644
--- a/src/OtherFunctions.cpp
+++ b/src/OtherFunctions.cpp
@@ -284,14 +284,14 @@ static wxChar base16Lookup[BASE16_LOOKUP_MAX][2] = {
 };
 
 
-// Returns a BASE16 encoded byte array
+// Returns a BASE16 encoded mule_byte array
 //
 // [In]
-//   buffer: Pointer to byte array
+//   buffer: Pointer to mule_byte array
 //   bufLen: Lenght of buffer array
 //
 // [Return]
-//   wxString object with BASE16 encoded byte array
+//   wxString object with BASE16 encoded mule_byte array
 wxString EncodeBase16(const unsigned char* buffer, unsigned int bufLen)
 {
 	wxString Base16Buff;
@@ -305,15 +305,15 @@ wxString EncodeBase16(const unsigned char* buffer, unsigned int bufLen)
 }
 
 
-// Decodes a BASE16 string into a byte array
+// Decodes a BASE16 string into a mule_byte array
 //
 // [In]
 //   base16Buffer: String containing BASE16
 //   base16BufLen: Lenght BASE16 coded string's length
 //
 // [Out]
-//   buffer: byte array containing decoded string
-unsigned int DecodeBase16(const wxString &base16Buffer, unsigned int base16BufLen, byte *buffer)
+//   buffer: mule_byte array containing decoded string
+unsigned int DecodeBase16(const wxString &base16Buffer, unsigned int base16BufLen, mule_byte *buffer)
 {
 	if (base16BufLen & 1) {
 		return 0;
@@ -323,7 +323,7 @@ unsigned int DecodeBase16(const wxString &base16Buffer, unsigned int base16BufLe
 	for(unsigned int i = 0; i < base16BufLen; ++i) {
 		int lookup = toupper(base16Buffer[i]) - wxT('0');
 		// Check to make sure that the given word falls inside a valid range
-		byte word = (lookup < 0 || lookup >= BASE16_LOOKUP_MAX) ?
+		mule_byte word = (lookup < 0 || lookup >= BASE16_LOOKUP_MAX) ?
 			0xFF : base16Lookup[lookup][1];
 		unsigned idx = i >> 1;
 		buffer[idx] = (i & 1) ? // odd or even?
@@ -334,14 +334,14 @@ unsigned int DecodeBase16(const wxString &base16Buffer, unsigned int base16BufLe
 }
 
 
-// Returns a BASE32 encoded byte array
+// Returns a BASE32 encoded mule_byte array
 //
 // [In]
-//   buffer: Pointer to byte array
+//   buffer: Pointer to mule_byte array
 //   bufLen: Lenght of buffer array
 //
 // [Return]
-//   wxString object with BASE32 encoded byte array
+//   wxString object with BASE32 encoded mule_byte array
 wxString EncodeBase32(const unsigned char* buffer, unsigned int bufLen)
 {
 	wxString Base32Buff;
@@ -349,7 +349,7 @@ wxString EncodeBase32(const unsigned char* buffer, unsigned int bufLen)
 	unsigned char word;
 
 	for(i = 0, index = 0; i < bufLen;) {
-		// Is the current word going to span a byte boundary?
+		// Is the current word going to span a mule_byte boundary?
 		if (index > 3) {
 			word = (buffer[i] & (0xFF >> index));
 			index = (index + 5) % 8;
@@ -372,14 +372,14 @@ wxString EncodeBase32(const unsigned char* buffer, unsigned int bufLen)
 }
 
 
-// Decodes a BASE32 string into a byte array
+// Decodes a BASE32 string into a mule_byte array
 //
 // [In]
 //   base32Buffer: String containing BASE32
 //   base32BufLen: Lenght BASE32 coded string's length
 //
 // [Out]
-//   buffer: byte array containing decoded string
+//   buffer: mule_byte array containing decoded string
 // [Return]
 //   nDecodeLen:
 unsigned int DecodeBase32(const wxString &base32Buffer, unsigned int base32BufLen, unsigned char *buffer)
@@ -414,7 +414,7 @@ unsigned int DecodeBase32(const wxString &base32Buffer, unsigned int base32BufLe
 		nCount += 5;
 		if (nCount >= 8)
 		{
-			*buffer++ = (byte)( nBits >> (nCount - 8) );
+			*buffer++ = (mule_byte)( nBits >> (nCount - 8) );
 			nCount -= 8;
 		}
 		nBits <<= 5;
diff --git a/src/Packet.cpp b/src/Packet.cpp
index d0e93b443..0e4c55886 100644
--- a/src/Packet.cpp
+++ b/src/Packet.cpp
@@ -47,12 +47,12 @@ CPacket::CPacket(CPacket &p)
 	memcpy(head, p.head, sizeof head);
 	tempbuffer	= NULL;
 	if (p.completebuffer) {
-		completebuffer	= new byte[size + 10];;
+		completebuffer	= new mule_byte[size + 10];;
 		pBuffer	= completebuffer + sizeof(Header_Struct);
 	} else {
 		completebuffer	= NULL;
 		if (p.pBuffer) {
-			pBuffer = new byte[size];
+			pBuffer = new mule_byte[size];
 		} else {
 			pBuffer = NULL;
 		}
@@ -77,7 +77,7 @@ CPacket::CPacket(uint8 protocol)
 }
 
 // only used for receiving packets
-CPacket::CPacket(byte* rawHeader, byte *buf)
+CPacket::CPacket(mule_byte* rawHeader, mule_byte *buf)
 {
 	memset(head, 0, sizeof head);
 	Header_Struct* header = reinterpret_cast<Header_Struct*>(rawHeader);
@@ -104,7 +104,7 @@ CPacket::CPacket(const CMemFile& datafile, uint8 protocol, uint8 ucOpcode)
 	m_bFromPF	= false;
 	memset(head, 0, sizeof head);
 	tempbuffer = NULL;
-	completebuffer = new byte[size + sizeof(Header_Struct)/*Why this 4?*/];
+	completebuffer = new mule_byte[size + sizeof(Header_Struct)/*Why this 4?*/];
 	pBuffer = completebuffer + sizeof(Header_Struct);
 
 	// Write contents of MemFile to buffer (while keeping original position in file)
@@ -126,7 +126,7 @@ CPacket::CPacket(int8 in_opcode, uint32 in_size, uint8 protocol, bool bFromPF)
 	memset(head, 0, sizeof head);
 	tempbuffer	= NULL;
 	if (in_size) {
-		completebuffer = new byte[in_size + sizeof(Header_Struct) + 4 /*Why this 4?*/];
+		completebuffer = new mule_byte[in_size + sizeof(Header_Struct) + 4 /*Why this 4?*/];
 		pBuffer = completebuffer + sizeof(Header_Struct);
 		memset(completebuffer, 0, in_size + sizeof(Header_Struct) + 4 /*Why this 4?*/);
 	} else {
@@ -136,7 +136,7 @@ CPacket::CPacket(int8 in_opcode, uint32 in_size, uint8 protocol, bool bFromPF)
 }
 
 // only used for splitted packets!
-CPacket::CPacket(byte* pPacketPart, uint32 nSize, bool bLast, bool bFromPF)
+CPacket::CPacket(mule_byte* pPacketPart, uint32 nSize, bool bLast, bool bFromPF)
 {
 	size		= nSize - sizeof(Header_Struct);
 	opcode		= 0;
@@ -166,7 +166,7 @@ CPacket::~CPacket()
 	}
 }
 
-uint32 CPacket::GetPacketSizeFromHeader(const byte* rawHeader)
+uint32 CPacket::GetPacketSizeFromHeader(const mule_byte* rawHeader)
 {
 	const Header_Struct* header = reinterpret_cast<const Header_Struct*>(rawHeader);
 	uint32 size = ENDIAN_SWAP_32(header->packetlength);
@@ -175,13 +175,13 @@ uint32 CPacket::GetPacketSizeFromHeader(const byte* rawHeader)
 	return size - 1;
 }
 
-void CPacket::CopyToDataBuffer(unsigned int offset, const byte* data, unsigned int n)
+void CPacket::CopyToDataBuffer(unsigned int offset, const mule_byte* data, unsigned int n)
 {
 	wxASSERT(offset + n <= size + 1);
 	memcpy(pBuffer + offset, data, n);
 }
 
-byte* CPacket::GetPacket() {
+mule_byte* CPacket::GetPacket() {
 	if (completebuffer) {
 		if (!m_bSplitted) {
 			memcpy(completebuffer, GetHeader(), sizeof(Header_Struct));
@@ -192,19 +192,19 @@ byte* CPacket::GetPacket() {
 			delete [] tempbuffer;
 			tempbuffer = NULL;
 		}
-		tempbuffer = new byte[size + sizeof(Header_Struct) + 4 /* why this 4?*/];
+		tempbuffer = new mule_byte[size + sizeof(Header_Struct) + 4 /* why this 4?*/];
 		memcpy(tempbuffer    , GetHeader(), sizeof(Header_Struct));
 		memcpy(tempbuffer + sizeof(Header_Struct), pBuffer    , size);
 		return tempbuffer;
 	}
 }
 
-byte* CPacket::DetachPacket() {
+mule_byte* CPacket::DetachPacket() {
 	if (completebuffer) {
 		if (!m_bSplitted) {
 			memcpy(completebuffer, GetHeader(), sizeof(Header_Struct));
 		}
-		byte* result = completebuffer;
+		mule_byte* result = completebuffer;
 		completebuffer = pBuffer = NULL;
 		return result;
 	} else{
@@ -212,16 +212,16 @@ byte* CPacket::DetachPacket() {
 			delete[] tempbuffer;
 			tempbuffer = NULL;
 		}
-		tempbuffer = new byte[size+sizeof(Header_Struct)+4 /* Why this 4?*/];
+		tempbuffer = new mule_byte[size+sizeof(Header_Struct)+4 /* Why this 4?*/];
 		memcpy(tempbuffer,GetHeader(),sizeof(Header_Struct));
 		memcpy(tempbuffer+sizeof(Header_Struct),pBuffer,size);
-		byte* result = tempbuffer;
+		mule_byte* result = tempbuffer;
 		tempbuffer = 0;
 		return result;
 	}
 }
 
-byte* CPacket::GetHeader() {
+mule_byte* CPacket::GetHeader() {
 	wxASSERT( !m_bSplitted );
 
 	Header_Struct* header = reinterpret_cast<Header_Struct*>(head);
@@ -232,7 +232,7 @@ byte* CPacket::GetHeader() {
 	return head;
 }
 
-byte* CPacket::GetUDPHeader() {
+mule_byte* CPacket::GetUDPHeader() {
 	wxASSERT( !m_bSplitted );
 
 	memset(head, 0, 6);
@@ -249,7 +249,7 @@ void CPacket::PackPacket()
 	wxASSERT(!m_bSplitted);
 
 	uLongf newsize = size + 300;
-	byte* output = new byte[newsize];
+	mule_byte* output = new mule_byte[newsize];
 
 	uint16 result = compress2(output, &newsize, pBuffer, size, Z_BEST_COMPRESSION);
 
@@ -287,7 +287,7 @@ bool CPacket::UnPackPacket(uint32 uMaxDecompressedSize) {
 		nNewSize = uMaxDecompressedSize;
 	}
 
-	byte* unpack = new byte[nNewSize];
+	mule_byte* unpack = new mule_byte[nNewSize];
 	uLongf unpackedsize = nNewSize;
 	uint16 result = uncompress(unpack, &unpackedsize, pBuffer, size);
 
diff --git a/src/Packet.h b/src/Packet.h
index 3e0fe7163..44eea4b21 100644
--- a/src/Packet.h
+++ b/src/Packet.h
@@ -41,19 +41,19 @@ class CPacket {
 public:
 	CPacket(CPacket &p);
 	CPacket(uint8 protocol);
-	CPacket(byte* header, byte *buf); // only used for receiving packets
+	CPacket(mule_byte* header, mule_byte *buf); // only used for receiving packets
 	CPacket(const CMemFile& datafile, uint8 protocol, uint8 ucOpcode);
 	CPacket(int8 in_opcode, uint32 in_size, uint8 protocol, bool bFromPF = true);
-	CPacket(byte* pPacketPart, uint32 nSize, bool bLast, bool bFromPF = true); // only used for splitted packets!
+	CPacket(mule_byte* pPacketPart, uint32 nSize, bool bLast, bool bFromPF = true); // only used for splitted packets!
 
 	~CPacket();
 
-	byte*			GetHeader();
-	byte*			GetUDPHeader();
-	byte*			GetPacket();
-	byte*			DetachPacket();
+	mule_byte*		GetHeader();
+	mule_byte*		GetUDPHeader();
+	mule_byte*		GetPacket();
+	mule_byte*		DetachPacket();
 	uint32			GetRealPacketSize() const	{ return size + 6; }
-	static uint32		GetPacketSizeFromHeader(const byte* rawHeader);
+	static uint32		GetPacketSizeFromHeader(const mule_byte* rawHeader);
 	bool			IsSplitted()		{ return m_bSplitted; }
 	bool			IsLastSplitted()	{ return m_bLastSplitted; }
 	void			PackPacket();
@@ -66,9 +66,9 @@ class CPacket {
 	uint32			GetPacketSize() const	{ return size; }
 	uint8			GetProtocol() const	{ return prot; }
 	void			SetProtocol(uint8 p)	{ prot = p; }
-	const byte*	GetDataBuffer(void) const { return pBuffer; }
+	const mule_byte*	GetDataBuffer(void) const { return pBuffer; }
 	void			Copy16ToDataBuffer(const void* data);
-	void			CopyToDataBuffer(unsigned int offset, const byte* data, unsigned int n);
+	void			CopyToDataBuffer(unsigned int offset, const mule_byte* data, unsigned int n);
 	void			CopyUInt32ToDataBuffer(uint32 data, unsigned int offset = 0);
 
 private:
@@ -82,10 +82,10 @@ class CPacket {
 	bool		m_bLastSplitted;
 	bool		m_bPacked;
 	bool		m_bFromPF;
-	byte		head[6];
-	byte*		tempbuffer;
-	byte*		completebuffer;
-	byte*		pBuffer;
+	mule_byte	head[6];
+	mule_byte*	tempbuffer;
+	mule_byte*	completebuffer;
+	mule_byte*	pBuffer;
 };
 
 #endif // PACKET_H
diff --git a/src/PartFile.cpp b/src/PartFile.cpp
index 52ee65b0f..1728f77fc 100644
--- a/src/PartFile.cpp
+++ b/src/PartFile.cpp
@@ -126,7 +126,7 @@ class PartFileBufferedData
 	uint64 end;						// This is the end offset of the data
 	Requested_Block_Struct *block;	// This is the requested block that this data relates to
 
-	PartFileBufferedData(CFileAutoClose& file, byte * data, uint64 _start, uint64 _end, Requested_Block_Struct *_block)
+	PartFileBufferedData(CFileAutoClose& file, mule_byte * data, uint64 _start, uint64 _end, Requested_Block_Struct *_block)
 		: start(_start), end(_end), block(_block)
 	{
 		area.StartWriteAt(file, start, end-start+1);
@@ -2877,7 +2877,7 @@ int CPartFile::GetCommonFilePenalty()
 // Kry - transize is 32bits, no packet can be more than that (this is
 // compressed size). Even 32bits is too much imho.As for the return size,
 // look at the lenData below.
-uint32 CPartFile::WriteToBuffer(uint32 transize, byte* data, uint64 start, uint64 end, Requested_Block_Struct *block, const CUpDownClient* client)
+uint32 CPartFile::WriteToBuffer(uint32 transize, mule_byte* data, uint64 start, uint64 end, Requested_Block_Struct *block, const CUpDownClient* client)
 {
 	// Increment transferred bytes counter for this file
 	transferred += transize;
diff --git a/src/PartFile.h b/src/PartFile.h
index fd41b1481..0a1e00795 100644
--- a/src/PartFile.h
+++ b/src/PartFile.h
@@ -162,7 +162,7 @@ class CPartFile : public CKnownFile {
 	int	getPartfileStatusRang() const;
 
 	// Barry - Added as replacement for BlockReceived to buffer data before writing to disk
-	uint32	WriteToBuffer(uint32 transize, byte *data, uint64 start, uint64 end, Requested_Block_Struct *block, const CUpDownClient* client);
+	uint32	WriteToBuffer(uint32 transize, mule_byte *data, uint64 start, uint64 end, Requested_Block_Struct *block, const CUpDownClient* client);
 	void	FlushBuffer(bool fromAICHRecoveryDataAvailable = false);
 
 	// Barry - Added to prevent list containing deleted blocks on shutdown
diff --git a/src/SHAHashSet.h b/src/SHAHashSet.h
index 674641711..3e69552ae 100644
--- a/src/SHAHashSet.h
+++ b/src/SHAHashSet.h
@@ -104,12 +104,12 @@ class CUpDownClient;
 class CAICHHash
 {
 private:
-	byte m_abyBuffer[HASHSIZE];
+	mule_byte m_abyBuffer[HASHSIZE];
 
 public:
 	CAICHHash()				{ memset(m_abyBuffer, 0, HASHSIZE); }
 	CAICHHash(CFileDataIO* file)		{ Read(file); }
-	CAICHHash(byte* data)			{ Read(data); }
+	CAICHHash(mule_byte* data)		{ Read(data); }
 	CAICHHash(const CAICHHash& k1)		{ *this = k1; }
 	~CAICHHash() {}
 	CAICHHash& operator=(const CAICHHash& k1)
@@ -124,9 +124,9 @@ class CAICHHash
 	friend bool operator!=(const CAICHHash& k1,const CAICHHash& k2)	{ return !(k1 == k2); }
 	void Read(CFileDataIO* file);
 	void Write(CFileDataIO* file) const;
-	void Read(byte* data)			{ memcpy(m_abyBuffer, data, HASHSIZE); }
+	void Read(mule_byte* data)		{ memcpy(m_abyBuffer, data, HASHSIZE); }
 	wxString GetString() const;
-	byte* GetRawHash()			{ return m_abyBuffer; }
+	mule_byte* GetRawHash()			{ return m_abyBuffer; }
 	static uint32 GetHashSize()		{ return HASHSIZE;}
 	unsigned int DecodeBase32(const wxString &base32);
 };
diff --git a/src/SafeFile.cpp b/src/SafeFile.cpp
index adb4b887b..041a6a26c 100644
--- a/src/SafeFile.cpp
+++ b/src/SafeFile.cpp
@@ -397,7 +397,7 @@ CTag *CFileDataIO::ReadTag(bool bOptACP) const
 {
 	CTag *retVal = NULL;
 	wxString name;
-	byte type = 0;
+	mule_byte type = 0;
 	try {
 		type = ReadUInt8();
 		name = ReadString(false);
diff --git a/src/SearchList.cpp b/src/SearchList.cpp
index caaaf92c3..d0ab4b023 100644
--- a/src/SearchList.cpp
+++ b/src/SearchList.cpp
@@ -500,7 +500,7 @@ void CSearchList::OnGlobalSearchTimer(CTimerEvent& WXUNUSED(evt))
 }
 
 
-void CSearchList::ProcessSharedFileList(const byte* in_packet, uint32 size,
+void CSearchList::ProcessSharedFileList(const mule_byte* in_packet, uint32 size,
 	CUpDownClient* sender, bool *moreResultsAvailable, const wxString& directory)
 {
 	wxCHECK_RET(sender, wxT("No sender in search-results from client."));
@@ -991,7 +991,7 @@ void CSearchList::KademliaSearchKeyword(uint32_t searchID, const Kademlia::CUInt
 	EUtf8Str eStrEncode = utf8strRaw;
 
 	CMemFile temp(250);
-	byte fileid[16];
+	mule_byte fileid[16];
 	fileID->ToByteArray(fileid);
 	temp.WriteHash(CMD4Hash(fileid));
 
diff --git a/src/SearchList.h b/src/SearchList.h
index 33428754c..981c26c76 100644
--- a/src/SearchList.h
+++ b/src/SearchList.h
@@ -128,7 +128,7 @@ class CSearchList : public wxEvtHandler
 	 * @param moreResultsAvailable Set to a value specifying if more results are available.
 	 * @param directory The directory containing the shared files.
 	 */
-	void	ProcessSharedFileList(const byte* packet, uint32 size, CUpDownClient* sender, bool* moreResultsAvailable, const wxString& directory);
+	void	ProcessSharedFileList(const mule_byte* packet, uint32 size, CUpDownClient* sender, bool* moreResultsAvailable, const wxString& directory);
 
 	/**
 	 * Processes a search-result sent via TCP from the local server. All results are added.
diff --git a/src/ServerList.cpp b/src/ServerList.cpp
index f2e14e0bd..663923f9f 100644
--- a/src/ServerList.cpp
+++ b/src/ServerList.cpp
@@ -112,7 +112,7 @@ bool CServerList::LoadServerMet(const CPath& path)
 	try {
 		Notify_ServerFreeze();
 
-		byte version = servermet.ReadUInt8();
+		mule_byte version = servermet.ReadUInt8();
 
 		if (version != 0xE0 && version != MET_HEADER) {
 			AddLogLineC(CFormat(_("Server.met file corrupt, found invalid versiontag: 0x%x, size %i")) % version % sizeof(version));
@@ -290,7 +290,7 @@ void CServerList::ServerStats()
 			// if it doesn't get responsed, we don't count it as error but continue with a normal ping
 			ping_server->SetCryptPingReplyPending(true);
 			uint32 nPacketLen = 4 + (uint8)(rand() % 16); // max padding 16 bytes
-			CScopedArray<byte> pRawPacket(nPacketLen);
+			CScopedArray<mule_byte> pRawPacket(nPacketLen);
 			uint32 dwChallenge = (rand() << 17) | (rand() << 2) | (rand() & 0x03);
 			if (dwChallenge == 0) {
 				dwChallenge++;
diff --git a/src/ServerSocket.cpp b/src/ServerSocket.cpp
index f0e32e6f8..06c8bd194 100644
--- a/src/ServerSocket.cpp
+++ b/src/ServerSocket.cpp
@@ -226,7 +226,7 @@ void CServerSocket::OnReceive(int nErrorCode)
 	m_dwLastTransmission = GetTickCount();
 }
 
-bool CServerSocket::ProcessPacket(const byte* packet, uint32 size, int8 opcode)
+bool CServerSocket::ProcessPacket(const mule_byte* packet, uint32 size, int8 opcode)
 {
 	try {
 		AddDebugLogLineN( logServer, wxT("Processing Server Packet: ") );
diff --git a/src/ServerSocket.h b/src/ServerSocket.h
index 155e8244a..b998a107d 100644
--- a/src/ServerSocket.h
+++ b/src/ServerSocket.h
@@ -65,7 +65,7 @@ class CServerSocket : public CEMSocket
 	uint32 GetServerIP() const;
 
 private:
-	bool	ProcessPacket(const byte* packet, uint32 size, int8 opcode);
+	bool	ProcessPacket(const mule_byte* packet, uint32 size, int8 opcode);
 	void	SetConnectionState(sint8 newstate);
 	CServerConnect*	serverconnect;
 	sint8	connectionstate;
diff --git a/src/ServerUDPSocket.cpp b/src/ServerUDPSocket.cpp
index 4e840c0e0..7c8edb2e0 100644
--- a/src/ServerUDPSocket.cpp
+++ b/src/ServerUDPSocket.cpp
@@ -60,12 +60,12 @@ CServerUDPSocket::CServerUDPSocket(amuleIPV4Address &address, const CProxyData *
 }
 
 
-void CServerUDPSocket::OnPacketReceived(uint32 serverip, uint16 serverport, byte* buffer, size_t length)
+void CServerUDPSocket::OnPacketReceived(uint32 serverip, uint16 serverport, mule_byte* buffer, size_t length)
 {
 	wxCHECK_RET(length >= 2, wxT("Invalid packet."));
 
 	size_t nPayLoadLen = length;
-	byte* pBuffer = buffer;
+	mule_byte* pBuffer = buffer;
 	CServer* pServer = theApp->serverlist->GetServerByIPUDP(serverip, serverport, true);
 	if (pServer && thePrefs::IsServerCryptLayerUDPEnabled() &&
 		((pServer->GetServerKeyUDP() != 0 && pServer->SupportsObfuscationUDP()) || (pServer->GetCryptPingReplyPending() && pServer->GetChallenge() != 0)))
@@ -365,7 +365,7 @@ void CServerUDPSocket::SendPacket(CPacket* packet, CServer* host, bool delPacket
 	// We might need to encrypt the packet for this server.
 	if (!rawpacket && thePrefs::IsServerCryptLayerUDPEnabled() && host->GetServerKeyUDP() != 0 && host->SupportsObfuscationUDP()) {
 		uint16 uRawPacketSize = packet->GetPacketSize() + 2;
-		byte* pRawPacket = new byte[uRawPacketSize];
+		mule_byte* pRawPacket = new mule_byte[uRawPacketSize];
 		memcpy(pRawPacket, packet->GetUDPHeader(), 2);
 		memcpy(pRawPacket + 2, packet->GetDataBuffer(), packet->GetPacketSize());
 
diff --git a/src/ServerUDPSocket.h b/src/ServerUDPSocket.h
index 6caed5ddc..7e2697549 100644
--- a/src/ServerUDPSocket.h
+++ b/src/ServerUDPSocket.h
@@ -44,7 +44,7 @@ class CServerUDPSocket : public CMuleUDPSocket
 	virtual void OnReceiveError(int errorCode, uint32 ip, uint16 port);
 
 private:
-	void	OnPacketReceived(uint32 ip, uint16 port, byte* buffer, size_t length);
+	void	OnPacketReceived(uint32 ip, uint16 port, mule_byte* buffer, size_t length);
 	void	ProcessPacket(CMemFile& packet, uint8 opcode, uint32 ip, uint16 port);
 	void	SendQueue();
 
diff --git a/src/Tag.cpp b/src/Tag.cpp
index 2e7e0c803..ab93d0865 100644
--- a/src/Tag.cpp
+++ b/src/Tag.cpp
@@ -286,7 +286,7 @@ uint32 CTag::GetBlobSize() const
 }
 
 
-const byte* CTag::GetBlob() const
+const mule_byte* CTag::GetBlob() const
 {
 	CHECK_TAG_TYPE(IsBlob(), Blob);
 
@@ -302,7 +302,7 @@ uint32 CTag::GetBsobSize() const
 }
 
 
-const byte* CTag::GetBsob() const
+const mule_byte* CTag::GetBsob() const
 {
 	CHECK_TAG_TYPE(IsBsob(), Bsob);
 
diff --git a/src/Tag.h b/src/Tag.h
index eb5ae2570..60e5457b3 100644
--- a/src/Tag.h
+++ b/src/Tag.h
@@ -70,10 +70,10 @@ class CTag
 
 	const CMD4Hash& GetHash() const;
 
-	const byte* GetBlob() const;
+	const mule_byte* GetBlob() const;
 	uint32 GetBlobSize() const;
 
-	const byte* GetBsob() const;
+	const mule_byte* GetBsob() const;
 	uint32 GetBsobSize() const;
 
 	CTag* CloneTag()		{ return new CTag(*this); }
@@ -268,11 +268,11 @@ class CTagHash : public CTag
 class CTagBsob : public CTag
 {
 public:
-	CTagBsob(const wxString& name, const byte* value, uint8 nSize)
+	CTagBsob(const wxString& name, const mule_byte* value, uint8 nSize)
 		: CTag(name)
 	{
 		m_uType = TAGTYPE_BSOB;
-		m_pData = new byte[nSize];
+		m_pData = new mule_byte[nSize];
 		memcpy(m_pData, value, nSize);
 		m_nSize = nSize;
 	}
@@ -281,11 +281,11 @@ class CTagBsob : public CTag
 class CTagBlob : public CTag
 {
 public:
-	CTagBlob(const wxString& name, const byte* value, uint8 nSize)
+	CTagBlob(const wxString& name, const mule_byte* value, uint8 nSize)
 		: CTag(name)
 	{
 		m_uType = TAGTYPE_BLOB;
-		m_pData = new byte[nSize];
+		m_pData = new mule_byte[nSize];
 		memcpy(m_pData, value, nSize);
 		m_nSize = nSize;
 	}
diff --git a/src/ThreadTasks.cpp b/src/ThreadTasks.cpp
index 327ab7ecf..49c6b74a9 100644
--- a/src/ThreadTasks.cpp
+++ b/src/ThreadTasks.cpp
@@ -42,7 +42,7 @@
 #endif
 
 //! This hash represents the value for an empty MD4 hashing
-const byte g_emptyMD4Hash[16] = {
+const mule_byte g_emptyMD4Hash[16] = {
 	0x31, 0xD6, 0xCF, 0xE0, 0xD1, 0x6A, 0xE9, 0x31,
 	0xB7, 0x3C, 0x59, 0xD7, 0xE0, 0xC0, 0x89, 0xC0 };
 
@@ -383,7 +383,7 @@ bool CAICHSyncTask::ConvertToKnown2ToKnown264()
 			CAICHHash aichHash(&oldfile);
 			uint32 nHashCount = oldfile.ReadUInt16();
 
-			CScopedArray<byte> buffer(nHashCount * CAICHHash::GetHashSize());
+			CScopedArray<mule_byte> buffer(nHashCount * CAICHHash::GetHashSize());
 
 			oldfile.Read(buffer.get(), nHashCount * CAICHHash::GetHashSize());
 			newfile.Write(aichHash.GetRawHash(), CAICHHash::GetHashSize());
diff --git a/src/Types.h b/src/Types.h
index b7dc85249..b1c27381f 100644
--- a/src/Types.h
+++ b/src/Types.h
@@ -41,7 +41,7 @@
 	#define LONGLONG(x) x##ll
 	#define ULONGLONG(x) x##llu
 #else
-	typedef unsigned __int8 byte;
+	typedef unsigned __int8 mule_byte;
 	typedef unsigned __int8 uint8_t;
 	typedef unsigned __int16 uint16_t;
 	typedef unsigned __int32 uint32_t;
@@ -107,7 +107,7 @@ typedef int8_t		sint8;
 typedef int16_t		sint16;
 typedef int32_t		sint32;
 typedef int64_t		sint64;
-typedef uint8_t		byte;
+typedef uint8_t		mule_byte;
 
 
 class CKnownFile;
diff --git a/src/UploadClient.cpp b/src/UploadClient.cpp
index a74ab92b6..9034f2137 100644
--- a/src/UploadClient.cpp
+++ b/src/UploadClient.cpp
@@ -282,7 +282,7 @@ void CUpDownClient::CreateNextBlockPackage()
 }
 
 
-void CUpDownClient::CreateStandardPackets(const byte* buffer, uint32 togo, Requested_Block_Struct* currentblock)
+void CUpDownClient::CreateStandardPackets(const mule_byte* buffer, uint32 togo, Requested_Block_Struct* currentblock)
 {
 	uint32 nPacketSize;
 
@@ -330,10 +330,10 @@ void CUpDownClient::CreateStandardPackets(const byte* buffer, uint32 togo, Reque
 }
 
 
-void CUpDownClient::CreatePackedPackets(const byte* buffer, uint32 togo, Requested_Block_Struct* currentblock)
+void CUpDownClient::CreatePackedPackets(const mule_byte* buffer, uint32 togo, Requested_Block_Struct* currentblock)
 {
 	uLongf newsize = togo+300;
-	CScopedArray<byte> output(newsize);
+	CScopedArray<mule_byte> output(newsize);
 	uint16 result = compress2(output.get(), &newsize, buffer, togo, 9);
 	if (result != Z_OK || togo <= newsize){
 		CreateStandardPackets(buffer, togo, currentblock);
@@ -836,7 +836,7 @@ void CUpDownClient::SetUploadFileID(const CMD4Hash& new_id)
 	SetUploadFileID(uploadingfile); // This will update queue count on old and new file.
 }
 
-void CUpDownClient::ProcessRequestPartsPacket(const byte* pachPacket, uint32 nSize, bool largeblocks) {
+void CUpDownClient::ProcessRequestPartsPacket(const mule_byte* pachPacket, uint32 nSize, bool largeblocks) {
 
 	CMemFile data(pachPacket, nSize);
 
diff --git a/src/kademlia/kademlia/Kademlia.cpp b/src/kademlia/kademlia/Kademlia.cpp
index f0f657b04..8e61008bb 100644
--- a/src/kademlia/kademlia/Kademlia.cpp
+++ b/src/kademlia/kademlia/Kademlia.cpp
@@ -499,7 +499,7 @@ bool CKademlia::IsRunningInLANMode()
 #include "../../CryptoPP_Inc.h"
 void KadGetKeywordHash(const wxString& rstrKeyword, Kademlia::CUInt128* pKadID)
 {
-	byte Output[16];
+	CryptoPP::byte Output[16];
 
 	#ifdef __WEAK_CRYPTO__
 		CryptoPP::Weak::MD4 md4_hasher;
diff --git a/src/kademlia/net/KademliaUDPListener.cpp b/src/kademlia/net/KademliaUDPListener.cpp
index e11dd5ea4..db79f239e 100644
--- a/src/kademlia/net/KademliaUDPListener.cpp
+++ b/src/kademlia/net/KademliaUDPListener.cpp
@@ -1668,7 +1668,7 @@ void CKademliaUDPListener::SendLegacyChallenge(uint32_t ip, uint16_t port, const
 }
 
 #if 0
-void CKademliaUDPListener::DebugClientOutput(const wxString& place, uint32 kad_ip, uint32 port, const byte* data, int len)
+void CKademliaUDPListener::DebugClientOutput(const wxString& place, uint32 kad_ip, uint32 port, const mule_byte* data, int len)
 {
 	uint32 ip = wxUINT32_SWAP_ALWAYS(kad_ip);
 	printf("Error on %s received from: %s\n",(const char*)unicode2char(place),(const char*)unicode2char(Uint32_16toStringIP_Port(ip,port)));
diff --git a/src/libs/common/StringFunctions.cpp b/src/libs/common/StringFunctions.cpp
index a9e6b7142..e0b3bc485 100644
--- a/src/libs/common/StringFunctions.cpp
+++ b/src/libs/common/StringFunctions.cpp
@@ -64,7 +64,7 @@ Unicode2CharBuf unicode2char(const wxChar* s)
 }
 
 
-static byte base16Chars[17] = "0123456789ABCDEF";
+static mule_byte base16Chars[17] = "0123456789ABCDEF";
 
 wxString URLEncode(const wxString& sIn)
 {
diff --git a/src/libs/ec/file_generator.pl b/src/libs/ec/file_generator.pl
index 199eaeb87..3a4902ea2 100755
--- a/src/libs/ec/file_generator.pl
+++ b/src/libs/ec/file_generator.pl
@@ -413,7 +413,7 @@ sub write_java_define_line {
 	my $second = $_[2];
 
 	if ($_[3]) {
-		if ($_[3] =~ /int8/) { $datatype = "byte"; }
+		if ($_[3] =~ /int8/) { $datatype = "mule_byte"; }
 		elsif ($_[3] =~ /(uint8|int16)/) { $datatype = "short"; }
 		elsif ($_[3] =~  /(uint16|int32)/) { $datatype = "int"; }
 		elsif ($_[3] =~ /(uint32|int64)/) { $datatype = "long"; }
diff --git a/src/libs/ec/java/ECCodes.java b/src/libs/ec/java/ECCodes.java
index 5fa986c01..dea0ddc5d 100644
--- a/src/libs/ec/java/ECCodes.java
+++ b/src/libs/ec/java/ECCodes.java
@@ -33,85 +33,85 @@
 public final static int EC_FLAG_UTF8_NUMBERS = 0x00000002;
 public final static int EC_FLAG_UNKNOWN_MASK = 0xff7f7f08;
 
-public final static byte EC_OP_NOOP                          = 0x01;
-public final static byte EC_OP_AUTH_REQ                      = 0x02;
-public final static byte EC_OP_AUTH_FAIL                     = 0x03;
-public final static byte EC_OP_AUTH_OK                       = 0x04;
-public final static byte EC_OP_FAILED                        = 0x05;
-public final static byte EC_OP_STRINGS                       = 0x06;
-public final static byte EC_OP_MISC_DATA                     = 0x07;
-public final static byte EC_OP_SHUTDOWN                      = 0x08;
-public final static byte EC_OP_ADD_LINK                      = 0x09;
-public final static byte EC_OP_STAT_REQ                      = 0x0A;
-public final static byte EC_OP_GET_CONNSTATE                 = 0x0B;
-public final static byte EC_OP_STATS                         = 0x0C;
-public final static byte EC_OP_GET_DLOAD_QUEUE               = 0x0D;
-public final static byte EC_OP_GET_ULOAD_QUEUE               = 0x0E;
-public final static byte EC_OP_GET_SHARED_FILES              = 0x10;
-public final static byte EC_OP_SHARED_SET_PRIO               = 0x11;
-public final static byte EC_OP_PARTFILE_SWAP_A4AF_THIS       = 0x16;
-public final static byte EC_OP_PARTFILE_SWAP_A4AF_THIS_AUTO  = 0x17;
-public final static byte EC_OP_PARTFILE_SWAP_A4AF_OTHERS     = 0x18;
-public final static byte EC_OP_PARTFILE_PAUSE                = 0x19;
-public final static byte EC_OP_PARTFILE_RESUME               = 0x1A;
-public final static byte EC_OP_PARTFILE_STOP                 = 0x1B;
-public final static byte EC_OP_PARTFILE_PRIO_SET             = 0x1C;
-public final static byte EC_OP_PARTFILE_DELETE               = 0x1D;
-public final static byte EC_OP_PARTFILE_SET_CAT              = 0x1E;
-public final static byte EC_OP_DLOAD_QUEUE                   = 0x1F;
-public final static byte EC_OP_ULOAD_QUEUE                   = 0x20;
-public final static byte EC_OP_SHARED_FILES                  = 0x22;
-public final static byte EC_OP_SHAREDFILES_RELOAD            = 0x23;
-public final static byte EC_OP_RENAME_FILE                   = 0x25;
-public final static byte EC_OP_SEARCH_START                  = 0x26;
-public final static byte EC_OP_SEARCH_STOP                   = 0x27;
-public final static byte EC_OP_SEARCH_RESULTS                = 0x28;
-public final static byte EC_OP_SEARCH_PROGRESS               = 0x29;
-public final static byte EC_OP_DOWNLOAD_SEARCH_RESULT        = 0x2A;
-public final static byte EC_OP_IPFILTER_RELOAD               = 0x2B;
-public final static byte EC_OP_GET_SERVER_LIST               = 0x2C;
-public final static byte EC_OP_SERVER_LIST                   = 0x2D;
-public final static byte EC_OP_SERVER_DISCONNECT             = 0x2E;
-public final static byte EC_OP_SERVER_CONNECT                = 0x2F;
-public final static byte EC_OP_SERVER_REMOVE                 = 0x30;
-public final static byte EC_OP_SERVER_ADD                    = 0x31;
-public final static byte EC_OP_SERVER_UPDATE_FROM_URL        = 0x32;
-public final static byte EC_OP_ADDLOGLINE                    = 0x33;
-public final static byte EC_OP_ADDDEBUGLOGLINE               = 0x34;
-public final static byte EC_OP_GET_LOG                       = 0x35;
-public final static byte EC_OP_GET_DEBUGLOG                  = 0x36;
-public final static byte EC_OP_GET_SERVERINFO                = 0x37;
-public final static byte EC_OP_LOG                           = 0x38;
-public final static byte EC_OP_DEBUGLOG                      = 0x39;
-public final static byte EC_OP_SERVERINFO                    = 0x3A;
-public final static byte EC_OP_RESET_LOG                     = 0x3B;
-public final static byte EC_OP_RESET_DEBUGLOG                = 0x3C;
-public final static byte EC_OP_CLEAR_SERVERINFO              = 0x3D;
-public final static byte EC_OP_GET_LAST_LOG_ENTRY            = 0x3E;
-public final static byte EC_OP_GET_PREFERENCES               = 0x3F;
-public final static byte EC_OP_SET_PREFERENCES               = 0x40;
-public final static byte EC_OP_CREATE_CATEGORY               = 0x41;
-public final static byte EC_OP_UPDATE_CATEGORY               = 0x42;
-public final static byte EC_OP_DELETE_CATEGORY               = 0x43;
-public final static byte EC_OP_GET_STATSGRAPHS               = 0x44;
-public final static byte EC_OP_STATSGRAPHS                   = 0x45;
-public final static byte EC_OP_GET_STATSTREE                 = 0x46;
-public final static byte EC_OP_STATSTREE                     = 0x47;
-public final static byte EC_OP_KAD_START                     = 0x48;
-public final static byte EC_OP_KAD_STOP                      = 0x49;
-public final static byte EC_OP_CONNECT                       = 0x4A;
-public final static byte EC_OP_DISCONNECT                    = 0x4B;
-public final static byte EC_OP_KAD_UPDATE_FROM_URL           = 0x4D;
-public final static byte EC_OP_KAD_BOOTSTRAP_FROM_IP         = 0x4E;
-public final static byte EC_OP_AUTH_SALT                     = 0x4F;
-public final static byte EC_OP_AUTH_PASSWD                   = 0x50;
-public final static byte EC_OP_IPFILTER_UPDATE               = 0x51;
-public final static byte EC_OP_GET_UPDATE                    = 0x52;
-public final static byte EC_OP_CLEAR_COMPLETED               = 0x53;
-public final static byte EC_OP_CLIENT_SWAP_TO_ANOTHER_FILE   = 0x54;
-public final static byte EC_OP_SHARED_FILE_SET_COMMENT       = 0x55;
-public final static byte EC_OP_SERVER_SET_STATIC_PRIO        = 0x56;
-public final static byte EC_OP_FRIEND                        = 0x57;
+public final static mule_byte EC_OP_NOOP                          = 0x01;
+public final static mule_byte EC_OP_AUTH_REQ                      = 0x02;
+public final static mule_byte EC_OP_AUTH_FAIL                     = 0x03;
+public final static mule_byte EC_OP_AUTH_OK                       = 0x04;
+public final static mule_byte EC_OP_FAILED                        = 0x05;
+public final static mule_byte EC_OP_STRINGS                       = 0x06;
+public final static mule_byte EC_OP_MISC_DATA                     = 0x07;
+public final static mule_byte EC_OP_SHUTDOWN                      = 0x08;
+public final static mule_byte EC_OP_ADD_LINK                      = 0x09;
+public final static mule_byte EC_OP_STAT_REQ                      = 0x0A;
+public final static mule_byte EC_OP_GET_CONNSTATE                 = 0x0B;
+public final static mule_byte EC_OP_STATS                         = 0x0C;
+public final static mule_byte EC_OP_GET_DLOAD_QUEUE               = 0x0D;
+public final static mule_byte EC_OP_GET_ULOAD_QUEUE               = 0x0E;
+public final static mule_byte EC_OP_GET_SHARED_FILES              = 0x10;
+public final static mule_byte EC_OP_SHARED_SET_PRIO               = 0x11;
+public final static mule_byte EC_OP_PARTFILE_SWAP_A4AF_THIS       = 0x16;
+public final static mule_byte EC_OP_PARTFILE_SWAP_A4AF_THIS_AUTO  = 0x17;
+public final static mule_byte EC_OP_PARTFILE_SWAP_A4AF_OTHERS     = 0x18;
+public final static mule_byte EC_OP_PARTFILE_PAUSE                = 0x19;
+public final static mule_byte EC_OP_PARTFILE_RESUME               = 0x1A;
+public final static mule_byte EC_OP_PARTFILE_STOP                 = 0x1B;
+public final static mule_byte EC_OP_PARTFILE_PRIO_SET             = 0x1C;
+public final static mule_byte EC_OP_PARTFILE_DELETE               = 0x1D;
+public final static mule_byte EC_OP_PARTFILE_SET_CAT              = 0x1E;
+public final static mule_byte EC_OP_DLOAD_QUEUE                   = 0x1F;
+public final static mule_byte EC_OP_ULOAD_QUEUE                   = 0x20;
+public final static mule_byte EC_OP_SHARED_FILES                  = 0x22;
+public final static mule_byte EC_OP_SHAREDFILES_RELOAD            = 0x23;
+public final static mule_byte EC_OP_RENAME_FILE                   = 0x25;
+public final static mule_byte EC_OP_SEARCH_START                  = 0x26;
+public final static mule_byte EC_OP_SEARCH_STOP                   = 0x27;
+public final static mule_byte EC_OP_SEARCH_RESULTS                = 0x28;
+public final static mule_byte EC_OP_SEARCH_PROGRESS               = 0x29;
+public final static mule_byte EC_OP_DOWNLOAD_SEARCH_RESULT        = 0x2A;
+public final static mule_byte EC_OP_IPFILTER_RELOAD               = 0x2B;
+public final static mule_byte EC_OP_GET_SERVER_LIST               = 0x2C;
+public final static mule_byte EC_OP_SERVER_LIST                   = 0x2D;
+public final static mule_byte EC_OP_SERVER_DISCONNECT             = 0x2E;
+public final static mule_byte EC_OP_SERVER_CONNECT                = 0x2F;
+public final static mule_byte EC_OP_SERVER_REMOVE                 = 0x30;
+public final static mule_byte EC_OP_SERVER_ADD                    = 0x31;
+public final static mule_byte EC_OP_SERVER_UPDATE_FROM_URL        = 0x32;
+public final static mule_byte EC_OP_ADDLOGLINE                    = 0x33;
+public final static mule_byte EC_OP_ADDDEBUGLOGLINE               = 0x34;
+public final static mule_byte EC_OP_GET_LOG                       = 0x35;
+public final static mule_byte EC_OP_GET_DEBUGLOG                  = 0x36;
+public final static mule_byte EC_OP_GET_SERVERINFO                = 0x37;
+public final static mule_byte EC_OP_LOG                           = 0x38;
+public final static mule_byte EC_OP_DEBUGLOG                      = 0x39;
+public final static mule_byte EC_OP_SERVERINFO                    = 0x3A;
+public final static mule_byte EC_OP_RESET_LOG                     = 0x3B;
+public final static mule_byte EC_OP_RESET_DEBUGLOG                = 0x3C;
+public final static mule_byte EC_OP_CLEAR_SERVERINFO              = 0x3D;
+public final static mule_byte EC_OP_GET_LAST_LOG_ENTRY            = 0x3E;
+public final static mule_byte EC_OP_GET_PREFERENCES               = 0x3F;
+public final static mule_byte EC_OP_SET_PREFERENCES               = 0x40;
+public final static mule_byte EC_OP_CREATE_CATEGORY               = 0x41;
+public final static mule_byte EC_OP_UPDATE_CATEGORY               = 0x42;
+public final static mule_byte EC_OP_DELETE_CATEGORY               = 0x43;
+public final static mule_byte EC_OP_GET_STATSGRAPHS               = 0x44;
+public final static mule_byte EC_OP_STATSGRAPHS                   = 0x45;
+public final static mule_byte EC_OP_GET_STATSTREE                 = 0x46;
+public final static mule_byte EC_OP_STATSTREE                     = 0x47;
+public final static mule_byte EC_OP_KAD_START                     = 0x48;
+public final static mule_byte EC_OP_KAD_STOP                      = 0x49;
+public final static mule_byte EC_OP_CONNECT                       = 0x4A;
+public final static mule_byte EC_OP_DISCONNECT                    = 0x4B;
+public final static mule_byte EC_OP_KAD_UPDATE_FROM_URL           = 0x4D;
+public final static mule_byte EC_OP_KAD_BOOTSTRAP_FROM_IP         = 0x4E;
+public final static mule_byte EC_OP_AUTH_SALT                     = 0x4F;
+public final static mule_byte EC_OP_AUTH_PASSWD                   = 0x50;
+public final static mule_byte EC_OP_IPFILTER_UPDATE               = 0x51;
+public final static mule_byte EC_OP_GET_UPDATE                    = 0x52;
+public final static mule_byte EC_OP_CLEAR_COMPLETED               = 0x53;
+public final static mule_byte EC_OP_CLIENT_SWAP_TO_ANOTHER_FILE   = 0x54;
+public final static mule_byte EC_OP_SHARED_FILE_SET_COMMENT       = 0x55;
+public final static mule_byte EC_OP_SERVER_SET_STATIC_PRIO        = 0x56;
+public final static mule_byte EC_OP_FRIEND                        = 0x57;
 
 public final static short EC_TAG_STRING                             = 0x0000;
 public final static short EC_TAG_PASSWD_HASH                        = 0x0001;
@@ -399,25 +399,25 @@
 public final static short 	EC_TAG_PREFS_KADEMLIA                     = 0x1E00;
 public final static short 		EC_TAG_KADEMLIA_UPDATE_URL                = 0x1E01;
 
-public final static byte EC_DETAIL_CMD           = 0x00;
-public final static byte EC_DETAIL_WEB           = 0x01;
-public final static byte EC_DETAIL_FULL          = 0x02;
-public final static byte EC_DETAIL_UPDATE        = 0x03;
-public final static byte EC_DETAIL_INC_UPDATE    = 0x04;
+public final static mule_byte EC_DETAIL_CMD           = 0x00;
+public final static mule_byte EC_DETAIL_WEB           = 0x01;
+public final static mule_byte EC_DETAIL_FULL          = 0x02;
+public final static mule_byte EC_DETAIL_UPDATE        = 0x03;
+public final static mule_byte EC_DETAIL_INC_UPDATE    = 0x04;
 
-public final static byte EC_SEARCH_LOCAL         = 0x00;
-public final static byte EC_SEARCH_GLOBAL        = 0x01;
-public final static byte EC_SEARCH_KAD           = 0x02;
-public final static byte EC_SEARCH_WEB           = 0x03;
+public final static mule_byte EC_SEARCH_LOCAL         = 0x00;
+public final static mule_byte EC_SEARCH_GLOBAL        = 0x01;
+public final static mule_byte EC_SEARCH_KAD           = 0x02;
+public final static mule_byte EC_SEARCH_WEB           = 0x03;
 
-public final static byte EC_VALUE_INTEGER        = 0x00;
-public final static byte EC_VALUE_ISTRING        = 0x01;
-public final static byte EC_VALUE_BYTES          = 0x02;
-public final static byte EC_VALUE_ISHORT         = 0x03;
-public final static byte EC_VALUE_TIME           = 0x04;
-public final static byte EC_VALUE_SPEED          = 0x05;
-public final static byte EC_VALUE_STRING         = 0x06;
-public final static byte EC_VALUE_DOUBLE         = 0x07;
+public final static mule_byte EC_VALUE_INTEGER        = 0x00;
+public final static mule_byte EC_VALUE_ISTRING        = 0x01;
+public final static mule_byte EC_VALUE_BYTES          = 0x02;
+public final static mule_byte EC_VALUE_ISHORT         = 0x03;
+public final static mule_byte EC_VALUE_TIME           = 0x04;
+public final static mule_byte EC_VALUE_SPEED          = 0x05;
+public final static mule_byte EC_VALUE_STRING         = 0x06;
+public final static mule_byte EC_VALUE_DOUBLE         = 0x07;
 
 public final static int EC_PREFS_CATEGORIES     = 0x00000001;
 public final static int EC_PREFS_GENERAL        = 0x00000002;
diff --git a/src/libs/ec/java/ECTagTypes.java b/src/libs/ec/java/ECTagTypes.java
index eca3b41e8..7a74464c3 100644
--- a/src/libs/ec/java/ECTagTypes.java
+++ b/src/libs/ec/java/ECTagTypes.java
@@ -26,16 +26,16 @@
 
 public interface ECTagTypes {
 
-public final static byte EC_TAGTYPE_UNKNOWN = 0;
-public final static byte EC_TAGTYPE_CUSTOM = 1;
-public final static byte EC_TAGTYPE_UINT8 = 2;
-public final static byte EC_TAGTYPE_UINT16 = 3;
-public final static byte EC_TAGTYPE_UINT32 = 4;
-public final static byte EC_TAGTYPE_UINT64 = 5;
-public final static byte EC_TAGTYPE_STRING = 6;
-public final static byte EC_TAGTYPE_DOUBLE = 7;
-public final static byte EC_TAGTYPE_IPV4 = 8;
-public final static byte EC_TAGTYPE_HASH16 = 9;
-public final static byte EC_TAGTYPE_UINT128 = 10;
+public final static mule_byte EC_TAGTYPE_UNKNOWN = 0;
+public final static mule_byte EC_TAGTYPE_CUSTOM = 1;
+public final static mule_byte EC_TAGTYPE_UINT8 = 2;
+public final static mule_byte EC_TAGTYPE_UINT16 = 3;
+public final static mule_byte EC_TAGTYPE_UINT32 = 4;
+public final static mule_byte EC_TAGTYPE_UINT64 = 5;
+public final static mule_byte EC_TAGTYPE_STRING = 6;
+public final static mule_byte EC_TAGTYPE_DOUBLE = 7;
+public final static mule_byte EC_TAGTYPE_IPV4 = 8;
+public final static mule_byte EC_TAGTYPE_HASH16 = 9;
+public final static mule_byte EC_TAGTYPE_UINT128 = 10;
 
 }
diff --git a/src/updownclient.h b/src/updownclient.h
index 2930df447..417ea4be7 100644
--- a/src/updownclient.h
+++ b/src/updownclient.h
@@ -202,7 +202,7 @@ class CUpDownClient : public CECID
 
 	void		ClearDownloadBlockRequests();
 	void		RequestSharedFileList();
-	void		ProcessSharedFileList(const byte* pachPacket, uint32 nSize, wxString& pszDirectory);
+	void		ProcessSharedFileList(const mule_byte* pachPacket, uint32 nSize, wxString& pszDirectory);
 	void		SendSharedDirectories();
 	void		SendSharedFilesOfDirectory(const wxString& strReqDir);
 
@@ -212,13 +212,13 @@ class CUpDownClient : public CECID
 
 	uint8		GetClientSoft() const		{ return m_clientSoft; }
 	void		ReGetClientSoft();
-	bool		ProcessHelloAnswer(const byte* pachPacket, uint32 nSize);
-	bool		ProcessHelloPacket(const byte* pachPacket, uint32 nSize);
+	bool		ProcessHelloAnswer(const mule_byte* pachPacket, uint32 nSize);
+	bool		ProcessHelloPacket(const mule_byte* pachPacket, uint32 nSize);
 	void		SendHelloAnswer();
 	bool		SendHelloPacket();
 	void		SendMuleInfoPacket(bool bAnswer, bool OSInfo = false);
-	bool		ProcessMuleInfoPacket(const byte* pachPacket, uint32 nSize);
-	void		ProcessMuleCommentPacket(const byte* pachPacket, uint32 nSize);
+	bool		ProcessMuleInfoPacket(const mule_byte* pachPacket, uint32 nSize);
+	void		ProcessMuleCommentPacket(const mule_byte* pachPacket, uint32 nSize);
 	bool		Compare(const CUpDownClient* tocomp, bool bIgnoreUserhash = false) const;
 	void		SetLastSrcReqTime()		{ m_dwLastSourceRequest = ::GetTickCount(); }
 	void		SetLastSrcAnswerTime()		{ m_dwLastSourceAnswer = ::GetTickCount(); }
@@ -234,17 +234,17 @@ class CUpDownClient : public CECID
 
 	bool		SafeSendPacket(CPacket* packet);
 
-	void		ProcessRequestPartsPacket(const byte* pachPacket, uint32 nSize, bool largeblocks);
+	void		ProcessRequestPartsPacket(const mule_byte* pachPacket, uint32 nSize, bool largeblocks);
 	void		ProcessRequestPartsPacketv2(const CMemFile& data);
 
 	void		SendPublicKeyPacket();
 	void		SendSignaturePacket();
-	void		ProcessPublicKeyPacket(const byte* pachPacket, uint32 nSize);
-	void		ProcessSignaturePacket(const byte* pachPacket, uint32 nSize);
+	void		ProcessPublicKeyPacket(const mule_byte* pachPacket, uint32 nSize);
+	void		ProcessSignaturePacket(const mule_byte* pachPacket, uint32 nSize);
 	uint8		GetSecureIdentState();
 
 	void		SendSecIdentStatePacket();
-	void		ProcessSecIdentStatePacket(const byte* pachPacket, uint32 nSize);
+	void		ProcessSecIdentStatePacket(const mule_byte* pachPacket, uint32 nSize);
 
 	uint8		GetInfoPacketsReceived() const	{ return m_byInfopacketsReceived; }
 	void		InfoPacketsReceived();
@@ -340,12 +340,12 @@ class CUpDownClient : public CECID
 	bool		AskForDownload();
 	void		SendStartupLoadReq();
 	void		SendFileRequest();
-	void		ProcessHashSet(const byte* packet, uint32 size);
+	void		ProcessHashSet(const mule_byte* packet, uint32 size);
 	bool		AddRequestForAnotherFile(CPartFile* file);
 	bool		DeleteFileRequest(CPartFile* file);
 	void		DeleteAllFileRequests();
 	void		SendBlockRequests();
-	void		ProcessBlockPacket(const byte* packet, uint32 size, bool packed, bool largeblocks);
+	void		ProcessBlockPacket(const mule_byte* packet, uint32 size, bool packed, bool largeblocks);
 	uint16		GetAvailablePartCount() const;
 
 	bool		SwapToAnotherFile(bool bIgnoreNoNeeded, bool ignoreSuspensions, bool bRemoveCompletely, CPartFile* toFile = NULL);
@@ -389,14 +389,14 @@ class CUpDownClient : public CECID
 	bool		IsSupportingAICH() const	{return m_fSupportsAICH & 0x01;}
 	void		SendAICHRequest(CPartFile* pForFile, uint16 nPart);
 	bool		IsAICHReqPending() const	{return m_fAICHRequested; }
-	void		ProcessAICHAnswer(const byte* packet, uint32 size);
-	void		ProcessAICHRequest(const byte* packet, uint32 size);
+	void		ProcessAICHAnswer(const mule_byte* packet, uint32 size);
+	void		ProcessAICHRequest(const mule_byte* packet, uint32 size);
 	void		ProcessAICHFileHash(CMemFile* data, const CPartFile* file);
 
 	EUtf8Str	GetUnicodeSupport() const;
 
 	// Barry - Process zip file as it arrives, don't need to wait until end of block
-	int		unzip(Pending_Block_Struct *block, byte *zipped, uint32 lenZipped, byte **unzipped, uint32 *lenUnzipped, int iRecursion = 0);
+	int		unzip(Pending_Block_Struct *block, mule_byte *zipped, uint32 lenZipped, mule_byte **unzipped, uint32 *lenUnzipped, int iRecursion = 0);
 	void		UpdateDisplayedInfo(bool force = false);
 	int		GetFileListRequested() const	{ return m_iFileListRequested; }
 	void		SetFileListRequested(int iFileListRequested) { m_iFileListRequested = iFileListRequested; }
@@ -413,7 +413,7 @@ class CUpDownClient : public CECID
 
 	const wxString& GetClientOSInfo() const		{ return m_sClientOSInfo; }
 
-	void		ProcessPublicIPAnswer(const byte* pbyData, uint32 uSize);
+	void		ProcessPublicIPAnswer(const mule_byte* pbyData, uint32 uSize);
 	void		SendPublicIPRequest();
 
 	/**
@@ -473,8 +473,8 @@ class CUpDownClient : public CECID
 
 	/* Kad buddy support */
 	// ID
-	const byte*	GetBuddyID() const		{ return m_achBuddyID; }
-	void		SetBuddyID(const byte* m_achTempBuddyID);
+	const mule_byte*	GetBuddyID() const	{ return m_achBuddyID; }
+	void		SetBuddyID(const mule_byte* m_achTempBuddyID);
 	bool		HasValidBuddyID() const		{ return m_bBuddyIDValid; }
 	/* IP */
 	void		SetBuddyIP( uint32 val )	{ m_nBuddyIP = val; }
@@ -789,7 +789,7 @@ class CUpDownClient : public CECID
 	ESourceFrom	m_nSourceFrom;
 
 	/* Kad Stuff */
-	byte		m_achBuddyID[16];
+	mule_byte	m_achBuddyID[16];
 	bool		m_bBuddyIDValid;
 	uint32		m_nBuddyIP;
 	uint16		m_nBuddyPort;
diff --git a/src/utils/fileview/KadFiles.cpp b/src/utils/fileview/KadFiles.cpp
index a2ded2495..4ace458d6 100644
--- a/src/utils/fileview/KadFiles.cpp
+++ b/src/utils/fileview/KadFiles.cpp
@@ -52,7 +52,7 @@ void DecodeLoadIndexDat(const CFileDataIO& file)
 #include "../../CryptoPP_Inc.h"
 void KadGetKeywordHash(const wxString& rstrKeyword, Kademlia::CUInt128* pKadID)
 {
-	byte Output[16];
+	CryptoPP::byte Output[16];
 #ifdef CRYPTOPP_ENABLE_NAMESPACE_WEAK
 	CryptoPP::Weak::MD4 md4_hasher;
 #else
@@ -62,7 +62,7 @@ void KadGetKeywordHash(const wxString& rstrKeyword, Kademlia::CUInt128* pKadID)
 	// This should be safe - we assume rstrKeyword is ANSI anyway.
 	Unicode2CharBuf ansi_buffer(unicode2UTF8(rstrKeyword));
 
-	md4_hasher.CalculateDigest(Output, (const byte *) (const char *) ansi_buffer, strlen(ansi_buffer));
+	md4_hasher.CalculateDigest(Output, (const CryptoPP::byte *) (const char *) ansi_buffer, strlen(ansi_buffer));
 
 	pKadID->SetValueBE(Output);
 }
diff --git a/unittests/tests/CTagTest.cpp b/unittests/tests/CTagTest.cpp
index a76d92ea2..8eb7a92c7 100644
--- a/unittests/tests/CTagTest.cpp
+++ b/unittests/tests/CTagTest.cpp
@@ -14,7 +14,7 @@ using namespace muleunit;
 
 DECLARE_SIMPLE(CTag)
 
-void test_taglist_serialization(TagPtrList & taglist, byte* packet, uint64 packet_len);
+void test_taglist_serialization(TagPtrList & taglist, mule_byte* packet, uint64 packet_len);
 
 template <class T1, class T2>
 void AssertEquals(const T1& a, const T2& b)
@@ -22,17 +22,17 @@ void AssertEquals(const T1& a, const T2& b)
 	ASSERT_EQUALS(a, b);
 }
 
-struct BLOBValue : std::vector<byte>
+struct BLOBValue : std::vector<mule_byte>
 {
-	BLOBValue(uint32 _length, const byte* _ptr)
-		: std::vector<byte > (_ptr, _ptr + _length)
+	BLOBValue(uint32 _length, const mule_byte* _ptr)
+		: std::vector<mule_byte > (_ptr, _ptr + _length)
 	{}
 };
 
-struct BSOBValue : std::vector<byte>
+struct BSOBValue : std::vector<mule_byte>
 {
-	BSOBValue(uint8 _length, const byte* _ptr)
-		: std::vector<byte > (_ptr, _ptr + _length)
+	BSOBValue(uint8 _length, const mule_byte* _ptr)
+		: std::vector<mule_byte > (_ptr, _ptr + _length)
 	{}
 };
 
@@ -249,7 +249,7 @@ void CheckTagData(CTag* tag, TName tagName, const V& tagValue)
 	CheckTagValue(valid_tag_value(tagValue), tag);
 }
 
-void test_taglist_serialization(TagPtrList& taglist, byte* packet, uint64 packet_len)
+void test_taglist_serialization(TagPtrList& taglist, mule_byte* packet, uint64 packet_len)
 {
 	CMemFile fout;
 
@@ -267,7 +267,7 @@ void test_taglist_serialization(TagPtrList& taglist, byte* packet, uint64 packet
 		ASSERT_EQUALS(packet_len, fout.GetLength());
 	}
 
-	std::vector<byte> buf(packet_len);
+	std::vector<mule_byte> buf(packet_len);
 
 	{
 		CONTEXT(wxT("Reading back serialized taglist bytes from CMemFile"));
@@ -281,7 +281,7 @@ void test_taglist_serialization(TagPtrList& taglist, byte* packet, uint64 packet
 	}
 }
 
-void ReadTagPtrList(TagPtrList& taglist, byte* packet, uint64 packet_len)
+void ReadTagPtrList(TagPtrList& taglist, mule_byte* packet, uint64 packet_len)
 {
 
 	CONTEXT(wxT("Reading taglist from buffer"));
@@ -296,7 +296,7 @@ void ReadTagPtrList(TagPtrList& taglist, byte* packet, uint64 packet_len)
 
 TEST_M(CTag, ReadTagList1, wxT("Kad: Parse taglist from Kad packet with UTF8 string #1"))
 {
-	byte packet[] = {
+	mule_byte packet[] = {
 		0x07,
 		/*Tag1*/ 0x02, 0x01, 0x00, 0x01, 0x22, 0x00, 0x47, 0x65, 0x6d, 0x20, 0x42, 0x6f, 0x79, 0x20, 0x2d,
 		0x20, 0x53, 0x61, 0x72, 0xc3, 0xa0, 0x20, 0x70, 0x65, 0x72, 0x63, 0x68, 0xc3, 0xa8, 0x20, 0x74,
@@ -328,7 +328,7 @@ TEST_M(CTag, ReadTagList1, wxT("Kad: Parse taglist from Kad packet with UTF8 str
 
 TEST_M(CTag, ReadTagList2, wxT("Kad: Parse taglist from Kad packet with UTF8 string #2"))
 {
-	byte packet[] = {
+	mule_byte packet[] = {
 		0x05,
 		/*Tag1*/0x02, 0x01, 0x00, 0x01, 0x33, 0x00, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x61,
 		0x74, 0x69, 0x6f, 0x6e, 0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x46, 0x69, 0x6c, 0x65, 0x20, 0x31,
@@ -358,7 +358,7 @@ TEST_M(CTag, ReadTagList2, wxT("Kad: Parse taglist from Kad packet with UTF8 str
 
 TEST_M(CTag, Float, wxT("Kad: Read/Write floats"))
 {
-	byte packet[] = {
+	mule_byte packet[] = {
 		0x02,
 		/*Tag1*/0x04, 0x01, 0x00, 0xFF, 0x79, 0xe9, 0xf6, 0x42,
 		/*Tag2*/0x04, 0x01, 0x00, 0xFF, 0x79, 0xd9, 0xd6, 0x42,
@@ -378,7 +378,7 @@ TEST_M(CTag, Float, wxT("Kad: Read/Write floats"))
 
 TEST_M(CTag, CMD4Hash, wxT("Kad: Read/Write CMD4Hash"))
 {
-	byte packet[] = {
+	mule_byte packet[] = {
 		0x01,
 		/*Tag1*/0x01,
 		0x01, 0x00, 0xFF,
@@ -401,7 +401,7 @@ TEST_M(CTag, CMD4Hash, wxT("Kad: Read/Write CMD4Hash"))
 }
 
 template<class T, class V>
-void check_single_kad_tag(byte* packet, size_t packet_len, T tagName, V tagValue)
+void check_single_kad_tag(mule_byte* packet, size_t packet_len, T tagName, V tagValue)
 {
 	CMemFile buf(packet, packet_len);
 	CONTEXT(wxT("Starting buffer: ") + toString(buf));
@@ -433,10 +433,10 @@ void check_single_kad_tag(byte* packet, size_t packet_len, T tagName, V tagValue
 
 TEST_M(CTag, KadBsob, wxT("Kad: Read/Write BSOB"))
 {
-	byte packet[] = {
+	mule_byte packet[] = {
 		/*Tag1*/ 0x0A, 0x01, 0x00, 0x02, 0x04, 0x01, 0x02, 0x03, 0x04,
 	};
-	byte raw_data[] = {0x01, 0x02, 0x03, 0x04};
+	mule_byte raw_data[] = {0x01, 0x02, 0x03, 0x04};
 	{
 		CONTEXT(wxT("Create BSOBValue"));
 		BSOBValue bsob(sizeof (raw_data), raw_data);
@@ -448,7 +448,7 @@ TEST_M(CTag, KadBsob, wxT("Kad: Read/Write BSOB"))
 
 TEST_M(CTag, KadInt64, wxT("Kad: Read/Write integer 64bit"))
 {
-	byte packet[] = {
+	mule_byte packet[] = {
 		/*Tag1*/ 0x0b, 0x01, 0x00, 0x02, 0x10, 0x11, 0x12, 0x13, 0x20, 0x21, 0x22, 0x23, // 64 bit int
 	};
 	check_single_kad_tag(packet, sizeof (packet), TAG_FILESIZE, 0x2322212013121110LL);
@@ -456,7 +456,7 @@ TEST_M(CTag, KadInt64, wxT("Kad: Read/Write integer 64bit"))
 
 TEST_M(CTag, KadInt32, wxT("Kad: Read/Write integer 32bit"))
 {
-	byte packet[] = {
+	mule_byte packet[] = {
 		/*Tag1*/ 0x03, 0x01, 0x00, 0x02, 0x12, 0x34, 0x56, 0x78, // 32 bit int
 	};
 	check_single_kad_tag(packet, sizeof (packet), TAG_FILESIZE, 0x78563412);
@@ -464,7 +464,7 @@ TEST_M(CTag, KadInt32, wxT("Kad: Read/Write integer 32bit"))
 
 TEST_M(CTag, KadInt16, wxT("Kad: Read/Write integer 16bit"))
 {
-	byte packet[] = {
+	mule_byte packet[] = {
 		/*Tag1*/ 0x08, 0x01, 0x00, 0x02, 0x12, 0x34, // 16 bit int
 	};
 	check_single_kad_tag(packet, sizeof (packet), TAG_FILESIZE, 0x3412);
@@ -472,7 +472,7 @@ TEST_M(CTag, KadInt16, wxT("Kad: Read/Write integer 16bit"))
 
 TEST_M(CTag, KadInt8, wxT("Kad: Read/Write integer  8bit"))
 {
-	byte packet[] = {
+	mule_byte packet[] = {
 		/*Tag1*/ 0x09, 0x01, 0x00, 0x02, 0x12, //  8 bit int
 	};
 	check_single_kad_tag(packet, sizeof (packet), TAG_FILESIZE, 0x12);
@@ -480,7 +480,7 @@ TEST_M(CTag, KadInt8, wxT("Kad: Read/Write integer  8bit"))
 
 TEST_M(CTag, ReadIntegers, wxT("Kad: Read/Write multiple integers"))
 {
-	byte packet[] = {
+	mule_byte packet[] = {
 		0x08,
 		/*Tag1*/ 0x03, 0x01, 0x00, 0x02, 0x12, 0x34, 0x56, 0x78, // 32 bit int
 		/*Tag2*/ 0x08, 0x01, 0x00, 0x02, 0x12, 0x34, // 16 bit int
@@ -589,7 +589,7 @@ TEST_M(CTag, KadTagNames, wxT("Kad: Test Kad tags (name=string) - write/read eve
 	TagPtrList taglist;
 	buf.Seek(0, wxFromStart);
 	size_t packet_len = buf.GetLength();
-	std::vector<byte> packet(packet_len);
+	std::vector<mule_byte> packet(packet_len);
 	buf.Read(&packet[0], packet_len);
 
 	ReadTagPtrList(taglist, &packet[0], packet_len);
@@ -681,14 +681,14 @@ TEST_M(CTag, ED2kTagNames, wxT("Ed2k: Test ed2k tags (name=id) - write/read ever
 
 TEST_M(CTag, Ed2kBlob1, wxT("Ed2k: Read/Write BLOB - numeric tagname"))
 {
-	byte packet[] = {
+	mule_byte packet[] = {
 		/*Tag1*/ 0x87, 0xFF, 0x04, 0x00, 0x00, 0x00,
 		0x01, 0x02, 0x03, 0x04,
 	};
 
 	CMemFile buf(packet, sizeof (packet));
 	buf.Seek(0, wxFromStart);
-	byte raw_data[] = {0x01, 0x02, 0x03, 0x04};
+	mule_byte raw_data[] = {0x01, 0x02, 0x03, 0x04};
 	{
 		CONTEXT(wxT("Create BLOBValue"));
 		BLOBValue blob(sizeof (raw_data), raw_data);
@@ -701,14 +701,14 @@ TEST_M(CTag, Ed2kBlob1, wxT("Ed2k: Read/Write BLOB - numeric tagname"))
 
 TEST_M(CTag, Ed2kBlob2, wxT("Ed2k: Read/Write BLOB - string tagname"))
 {
-	byte packet[] = {
+	mule_byte packet[] = {
 		/*Tag1*/ 0x07, 0x02, 0x00, 'A', 'A', 0x04, 0x00, 0x00, 0x00,
 		0x01, 0x02, 0x03, 0x04,
 	};
 
 	CMemFile buf(packet, sizeof (packet));
 	buf.Seek(0, wxFromStart);
-	byte raw_data[] = {0x01, 0x02, 0x03, 0x04};
+	mule_byte raw_data[] = {0x01, 0x02, 0x03, 0x04};
 	{
 		CONTEXT(wxT("Create BLOBValue"));
 		BLOBValue blob(sizeof (raw_data), raw_data);
diff --git a/unittests/tests/FileDataIOTest.cpp b/unittests/tests/FileDataIOTest.cpp
index cdb24c652..1d5ed2e43 100644
--- a/unittests/tests/FileDataIOTest.cpp
+++ b/unittests/tests/FileDataIOTest.cpp
@@ -668,7 +668,7 @@ DECLARE_SIMPLE(CMemFile);
 TEST(CMemFile, AttachedBuffer)
 {
 	const size_t BufferLength = 1024;
-	byte buffer[BufferLength];
+	mule_byte buffer[BufferLength];
 
 	for (size_t i = 0; i < BufferLength; ++i) {
 		buffer[i] = i & 0xFF;
@@ -694,15 +694,15 @@ TEST(CMemFile, AttachedBuffer)
 	ASSERT_RAISES(CRunTimeException, file.WriteUInt8(0));
 
 	// Init with invalid buffer should fail
-	ASSERT_RAISES(CRunTimeException, new CMemFile(static_cast<const byte*>(NULL), 1024));
-	ASSERT_RAISES(CRunTimeException, new CMemFile(static_cast<byte*>(NULL), 1024));
+	ASSERT_RAISES(CRunTimeException, new CMemFile(static_cast<const mule_byte*>(NULL), 1024));
+	ASSERT_RAISES(CRunTimeException, new CMemFile(static_cast<mule_byte*>(NULL), 1024));
 }
 
 
 TEST(CMemFile, ConstBuffer)
 {
-	byte arr[10];
-	CMemFile file(const_cast<const byte*>(arr), sizeof(arr));
+	mule_byte arr[10];
+	CMemFile file(const_cast<const mule_byte*>(arr), sizeof(arr));
 
 	ASSERT_RAISES(CRunTimeException, file.WriteUInt8(0));
 	ASSERT_RAISES(CRunTimeException, file.WriteUInt16(0));